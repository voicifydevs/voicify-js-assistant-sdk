/**
 * Voicify Assistant API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: V1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

let defaultBasePath = 'https://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class APLContext {
    'display'?: AlexaDisplay;
    'viewport'?: AlexaViewport;
    'system'?: AlexaSystem;
    'audioPlayer'?: PlaybackState;
    'geolocation'?: Geolocation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "display",
            "baseName": "Display",
            "type": "AlexaDisplay"
        },
        {
            "name": "viewport",
            "baseName": "Viewport",
            "type": "AlexaViewport"
        },
        {
            "name": "system",
            "baseName": "System",
            "type": "AlexaSystem"
        },
        {
            "name": "audioPlayer",
            "baseName": "AudioPlayer",
            "type": "PlaybackState"
        },
        {
            "name": "geolocation",
            "baseName": "Geolocation",
            "type": "Geolocation"
        }    ];

    static getAttributeTypeMap() {
        return APLContext.attributeTypeMap;
    }
}

export class APLSkillRequest {
    'context'?: APLContext;
    'version'?: string;
    'session'?: Session;
    'request'?: Request;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "APLContext"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "session",
            "baseName": "session",
            "type": "Session"
        },
        {
            "name": "request",
            "baseName": "request",
            "type": "Request"
        }    ];

    static getAttributeTypeMap() {
        return APLSkillRequest.attributeTypeMap;
    }
}

export class ActionIntent {
    'name'?: string;
    'displayName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ActionIntent.attributeTypeMap;
    }
}

export class ActionOutputContext {
    'name'?: string;
    'lifespanCount'?: number;
    'parameters'?: { [key: string]: any; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "lifespanCount",
            "baseName": "lifespanCount",
            "type": "number"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "{ [key: string]: any; }"
        }    ];

    static getAttributeTypeMap() {
        return ActionOutputContext.attributeTypeMap;
    }
}

export class ActionQueryResult {
    'queryText'?: string;
    'action'?: string;
    'parameters'?: { [key: string]: string; };
    'allRequiredParamsPresent'?: boolean;
    'fulfillmentText'?: string;
    'fulfillmentMessages'?: Array<FulfillmentMessage>;
    'outputContexts'?: Array<ActionOutputContext>;
    'intent'?: ActionIntent;
    'intentDetectionConfidence'?: number;
    'diagnosticInfo'?: any;
    'languageCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "queryText",
            "baseName": "queryText",
            "type": "string"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "allRequiredParamsPresent",
            "baseName": "allRequiredParamsPresent",
            "type": "boolean"
        },
        {
            "name": "fulfillmentText",
            "baseName": "fulfillmentText",
            "type": "string"
        },
        {
            "name": "fulfillmentMessages",
            "baseName": "fulfillmentMessages",
            "type": "Array<FulfillmentMessage>"
        },
        {
            "name": "outputContexts",
            "baseName": "outputContexts",
            "type": "Array<ActionOutputContext>"
        },
        {
            "name": "intent",
            "baseName": "intent",
            "type": "ActionIntent"
        },
        {
            "name": "intentDetectionConfidence",
            "baseName": "intentDetectionConfidence",
            "type": "number"
        },
        {
            "name": "diagnosticInfo",
            "baseName": "diagnosticInfo",
            "type": "any"
        },
        {
            "name": "languageCode",
            "baseName": "languageCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ActionQueryResult.attributeTypeMap;
    }
}

export class ActionRequest {
    'responseId'?: string;
    'session'?: string;
    'queryResult'?: ActionQueryResult;
    'originalDetectIntentRequest'?: OriginalDetectIntentRequest;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responseId",
            "baseName": "responseId",
            "type": "string"
        },
        {
            "name": "session",
            "baseName": "session",
            "type": "string"
        },
        {
            "name": "queryResult",
            "baseName": "queryResult",
            "type": "ActionQueryResult"
        },
        {
            "name": "originalDetectIntentRequest",
            "baseName": "originalDetectIntentRequest",
            "type": "OriginalDetectIntentRequest"
        }    ];

    static getAttributeTypeMap() {
        return ActionRequest.attributeTypeMap;
    }
}

export class Activity extends null<String, any> {
    'type'?: string;
    'id'?: string;
    'timestamp'?: Date;
    'localTimestamp'?: Date;
    'localTimezone'?: string;
    'serviceUrl'?: string;
    'channelId'?: string;
    'from'?: ChannelAccount;
    'conversation'?: ConversationAccount;
    'recipient'?: ChannelAccount;
    'textFormat'?: string;
    'attachmentLayout'?: string;
    'membersAdded'?: Array<ChannelAccount>;
    'membersRemoved'?: Array<ChannelAccount>;
    'reactionsAdded'?: Array<MessageReaction>;
    'reactionsRemoved'?: Array<MessageReaction>;
    'topicName'?: string;
    'historyDisclosed'?: boolean;
    'locale'?: string;
    'text'?: string;
    'speak'?: string;
    'inputHint'?: string;
    'summary'?: string;
    'suggestedActions'?: SuggestedActions;
    'attachments'?: Array<Attachment>;
    'entities'?: Array<Entity>;
    'channelData'?: any;
    'action'?: string;
    'replyToId'?: string;
    'label'?: string;
    'valueType'?: string;
    'value'?: any;
    'name'?: string;
    'relatesTo'?: ConversationReference;
    'code'?: string;
    'expiration'?: Date;
    'importance'?: string;
    'deliveryMode'?: string;
    'listenFor'?: Array<string>;
    'textHighlights'?: Array<TextHighlight>;
    'semanticAction'?: SemanticAction;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        },
        {
            "name": "localTimestamp",
            "baseName": "localTimestamp",
            "type": "Date"
        },
        {
            "name": "localTimezone",
            "baseName": "localTimezone",
            "type": "string"
        },
        {
            "name": "serviceUrl",
            "baseName": "serviceUrl",
            "type": "string"
        },
        {
            "name": "channelId",
            "baseName": "channelId",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "ChannelAccount"
        },
        {
            "name": "conversation",
            "baseName": "conversation",
            "type": "ConversationAccount"
        },
        {
            "name": "recipient",
            "baseName": "recipient",
            "type": "ChannelAccount"
        },
        {
            "name": "textFormat",
            "baseName": "textFormat",
            "type": "string"
        },
        {
            "name": "attachmentLayout",
            "baseName": "attachmentLayout",
            "type": "string"
        },
        {
            "name": "membersAdded",
            "baseName": "membersAdded",
            "type": "Array<ChannelAccount>"
        },
        {
            "name": "membersRemoved",
            "baseName": "membersRemoved",
            "type": "Array<ChannelAccount>"
        },
        {
            "name": "reactionsAdded",
            "baseName": "reactionsAdded",
            "type": "Array<MessageReaction>"
        },
        {
            "name": "reactionsRemoved",
            "baseName": "reactionsRemoved",
            "type": "Array<MessageReaction>"
        },
        {
            "name": "topicName",
            "baseName": "topicName",
            "type": "string"
        },
        {
            "name": "historyDisclosed",
            "baseName": "historyDisclosed",
            "type": "boolean"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "speak",
            "baseName": "speak",
            "type": "string"
        },
        {
            "name": "inputHint",
            "baseName": "inputHint",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "suggestedActions",
            "baseName": "suggestedActions",
            "type": "SuggestedActions"
        },
        {
            "name": "attachments",
            "baseName": "attachments",
            "type": "Array<Attachment>"
        },
        {
            "name": "entities",
            "baseName": "entities",
            "type": "Array<Entity>"
        },
        {
            "name": "channelData",
            "baseName": "channelData",
            "type": "any"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "replyToId",
            "baseName": "replyToId",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "relatesTo",
            "baseName": "relatesTo",
            "type": "ConversationReference"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "expiration",
            "baseName": "expiration",
            "type": "Date"
        },
        {
            "name": "importance",
            "baseName": "importance",
            "type": "string"
        },
        {
            "name": "deliveryMode",
            "baseName": "deliveryMode",
            "type": "string"
        },
        {
            "name": "listenFor",
            "baseName": "listenFor",
            "type": "Array<string>"
        },
        {
            "name": "textHighlights",
            "baseName": "textHighlights",
            "type": "Array<TextHighlight>"
        },
        {
            "name": "semanticAction",
            "baseName": "semanticAction",
            "type": "SemanticAction"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Activity.attributeTypeMap);
    }
}

export class AlexaDisplay {
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AlexaDisplay.attributeTypeMap;
    }
}

export class AlexaSystem {
    'apiAccessToken'?: string;
    'apiEndpoint'?: string;
    'application'?: Application;
    'user'?: User;
    'device'?: Device;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "apiAccessToken",
            "baseName": "apiAccessToken",
            "type": "string"
        },
        {
            "name": "apiEndpoint",
            "baseName": "apiEndpoint",
            "type": "string"
        },
        {
            "name": "application",
            "baseName": "application",
            "type": "Application"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "device",
            "baseName": "device",
            "type": "Device"
        }    ];

    static getAttributeTypeMap() {
        return AlexaSystem.attributeTypeMap;
    }
}

export class AlexaViewport {
    'experiences'?: Array<ViewportExperience>;
    'currentPixelWidth'?: number;
    'currentPixelHeight'?: number;
    'dpi'?: number;
    'pixelHeight'?: number;
    'pixelWidth'?: number;
    'touch'?: Array<string>;
    'keyboard'?: Array<string>;
    'shape'?: AlexaViewport.ShapeEnum;
    'video'?: VideoSupport;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "experiences",
            "baseName": "experiences",
            "type": "Array<ViewportExperience>"
        },
        {
            "name": "currentPixelWidth",
            "baseName": "currentPixelWidth",
            "type": "number"
        },
        {
            "name": "currentPixelHeight",
            "baseName": "currentPixelHeight",
            "type": "number"
        },
        {
            "name": "dpi",
            "baseName": "dpi",
            "type": "number"
        },
        {
            "name": "pixelHeight",
            "baseName": "pixelHeight",
            "type": "number"
        },
        {
            "name": "pixelWidth",
            "baseName": "pixelWidth",
            "type": "number"
        },
        {
            "name": "touch",
            "baseName": "touch",
            "type": "Array<string>"
        },
        {
            "name": "keyboard",
            "baseName": "keyboard",
            "type": "Array<string>"
        },
        {
            "name": "shape",
            "baseName": "shape",
            "type": "AlexaViewport.ShapeEnum"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "VideoSupport"
        }    ];

    static getAttributeTypeMap() {
        return AlexaViewport.attributeTypeMap;
    }
}

export namespace AlexaViewport {
    export enum ShapeEnum {
        SQUARE = <any> 'SQUARE',
        RECTANGLE = <any> 'RECTANGLE',
        ROUND = <any> 'ROUND'
    }
}
export class Application {
    'applicationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Application.attributeTypeMap;
    }
}

export class Attachment extends null<String, any> {
    'contentType'?: string;
    'contentUrl'?: string;
    'content'?: any;
    'name'?: string;
    'thumbnailUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contentType",
            "baseName": "contentType",
            "type": "string"
        },
        {
            "name": "contentUrl",
            "baseName": "contentUrl",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "any"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "thumbnailUrl",
            "baseName": "thumbnailUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Attachment.attributeTypeMap);
    }
}

export class BixbyActionRequest extends null<String, any> {
    'vivContext'?: VivContext;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "vivContext",
            "baseName": "$vivContext",
            "type": "VivContext"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BixbyActionRequest.attributeTypeMap);
    }
}

export class BixbyEventSearchRequest extends null<String, any> {
    'eventName'?: string;
    'locationName'?: string;
    'startDate'?: Date;
    'startTime'?: Date;
    'vivContext'?: VivContext;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "locationName",
            "baseName": "locationName",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "vivContext",
            "baseName": "$vivContext",
            "type": "VivContext"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BixbyEventSearchRequest.attributeTypeMap);
    }
}

export class BixbyGeneralQuestionRequest extends null<String, any> {
    'voicifyQuery'?: string;
    'vivContext'?: VivContext;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "voicifyQuery",
            "baseName": "voicifyQuery",
            "type": "string"
        },
        {
            "name": "vivContext",
            "baseName": "$vivContext",
            "type": "VivContext"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BixbyGeneralQuestionRequest.attributeTypeMap);
    }
}

export class BixbyGoToStepRequest extends null<String, any> {
    'stepNumber'?: number;
    'vivContext'?: VivContext;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stepNumber",
            "baseName": "stepNumber",
            "type": "number"
        },
        {
            "name": "vivContext",
            "baseName": "$vivContext",
            "type": "VivContext"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BixbyGoToStepRequest.attributeTypeMap);
    }
}

export class BixbyItemSelectedRequest extends null<String, any> {
    'itemId'?: string;
    'vivContext'?: VivContext;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "itemId",
            "type": "string"
        },
        {
            "name": "vivContext",
            "baseName": "$vivContext",
            "type": "VivContext"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BixbyItemSelectedRequest.attributeTypeMap);
    }
}

export class BixbyLatestMessageRequest extends null<String, any> {
    'latestMessageCategory'?: string;
    'vivContext'?: VivContext;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "latestMessageCategory",
            "baseName": "latestMessageCategory",
            "type": "string"
        },
        {
            "name": "vivContext",
            "baseName": "$vivContext",
            "type": "VivContext"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BixbyLatestMessageRequest.attributeTypeMap);
    }
}

export class BixbyListItem {
    'id'?: string;
    'title'?: string;
    'description'?: string;
    'image'?: MediaItemModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "MediaItemModel"
        }    ];

    static getAttributeTypeMap() {
        return BixbyListItem.attributeTypeMap;
    }
}

export class BixbyNumberRequest extends null<String, any> {
    'number'?: number;
    'vivContext'?: VivContext;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "vivContext",
            "baseName": "$vivContext",
            "type": "VivContext"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BixbyNumberRequest.attributeTypeMap);
    }
}

export class BixbyRecipeSearchRequest extends null<String, any> {
    'recipeName'?: string;
    'ingredientName'?: string;
    'mealType'?: string;
    'cookTime'?: Date;
    'vivContext'?: VivContext;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipeName",
            "baseName": "recipeName",
            "type": "string"
        },
        {
            "name": "ingredientName",
            "baseName": "ingredientName",
            "type": "string"
        },
        {
            "name": "mealType",
            "baseName": "mealType",
            "type": "string"
        },
        {
            "name": "cookTime",
            "baseName": "cookTime",
            "type": "Date"
        },
        {
            "name": "vivContext",
            "baseName": "$vivContext",
            "type": "VivContext"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BixbyRecipeSearchRequest.attributeTypeMap);
    }
}

export class BixbyResponse {
    'responseId'?: string;
    'ssml'?: string;
    'outputSpeech'?: string;
    'displayText'?: string;
    'displayTitle'?: string;
    'responseTemplate'?: string;
    'foregroundImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audioFile'?: MediaItemModel;
    'videoFile'?: MediaItemModel;
    'sessionAttributes'?: { [key: string]: any; };
    'hints'?: Array<string>;
    'listItems'?: Array<BixbyListItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responseId",
            "baseName": "responseId",
            "type": "string"
        },
        {
            "name": "ssml",
            "baseName": "ssml",
            "type": "string"
        },
        {
            "name": "outputSpeech",
            "baseName": "outputSpeech",
            "type": "string"
        },
        {
            "name": "displayText",
            "baseName": "displayText",
            "type": "string"
        },
        {
            "name": "displayTitle",
            "baseName": "displayTitle",
            "type": "string"
        },
        {
            "name": "responseTemplate",
            "baseName": "responseTemplate",
            "type": "string"
        },
        {
            "name": "foregroundImage",
            "baseName": "foregroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audioFile",
            "baseName": "audioFile",
            "type": "MediaItemModel"
        },
        {
            "name": "videoFile",
            "baseName": "videoFile",
            "type": "MediaItemModel"
        },
        {
            "name": "sessionAttributes",
            "baseName": "sessionAttributes",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "hints",
            "baseName": "hints",
            "type": "Array<string>"
        },
        {
            "name": "listItems",
            "baseName": "listItems",
            "type": "Array<BixbyListItem>"
        }    ];

    static getAttributeTypeMap() {
        return BixbyResponse.attributeTypeMap;
    }
}

export class CardAction {
    'type'?: string;
    'title'?: string;
    'image'?: string;
    'text'?: string;
    'displayText'?: string;
    'value'?: any;
    'channelData'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "displayText",
            "baseName": "displayText",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        },
        {
            "name": "channelData",
            "baseName": "channelData",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CardAction.attributeTypeMap;
    }
}

export class CardButton {
    'text'?: string;
    'postback'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "postback",
            "baseName": "postback",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardButton.attributeTypeMap;
    }
}

export class ChannelAccount extends null<String, any> {
    'id'?: string;
    'name'?: string;
    'aadObjectId'?: string;
    'role'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "aadObjectId",
            "baseName": "aadObjectId",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChannelAccount.attributeTypeMap);
    }
}

export class ConversationAccount extends null<String, any> {
    'isGroup'?: boolean;
    'conversationType'?: string;
    'id'?: string;
    'name'?: string;
    'aadObjectId'?: string;
    'role'?: string;
    'tenantId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isGroup",
            "baseName": "isGroup",
            "type": "boolean"
        },
        {
            "name": "conversationType",
            "baseName": "conversationType",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "aadObjectId",
            "baseName": "aadObjectId",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "tenantId",
            "baseName": "tenantId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConversationAccount.attributeTypeMap);
    }
}

export class ConversationReference {
    'activityId'?: string;
    'user'?: ChannelAccount;
    'bot'?: ChannelAccount;
    'conversation'?: ConversationAccount;
    'channelId'?: string;
    'serviceUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activityId",
            "baseName": "activityId",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "ChannelAccount"
        },
        {
            "name": "bot",
            "baseName": "bot",
            "type": "ChannelAccount"
        },
        {
            "name": "conversation",
            "baseName": "conversation",
            "type": "ConversationAccount"
        },
        {
            "name": "channelId",
            "baseName": "channelId",
            "type": "string"
        },
        {
            "name": "serviceUrl",
            "baseName": "serviceUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConversationReference.attributeTypeMap;
    }
}

export class ConversationSessionState {
    'id'?: string;
    'sessionAttributes'?: { [key: string]: any; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "sessionAttributes",
            "baseName": "sessionAttributes",
            "type": "{ [key: string]: any; }"
        }    ];

    static getAttributeTypeMap() {
        return ConversationSessionState.attributeTypeMap;
    }
}

export class CustomAssistantDevice {
    'id': string;
    'name': string;
    'supportsVideo'?: boolean;
    'supportsForegroundImage'?: boolean;
    'supportsBackgroundImage'?: boolean;
    'supportsAudio'?: boolean;
    'supportsSsml'?: boolean;
    'supportsDisplayText'?: boolean;
    'supportsVoiceInput'?: boolean;
    'supportsTextInput'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "supportsVideo",
            "baseName": "supportsVideo",
            "type": "boolean"
        },
        {
            "name": "supportsForegroundImage",
            "baseName": "supportsForegroundImage",
            "type": "boolean"
        },
        {
            "name": "supportsBackgroundImage",
            "baseName": "supportsBackgroundImage",
            "type": "boolean"
        },
        {
            "name": "supportsAudio",
            "baseName": "supportsAudio",
            "type": "boolean"
        },
        {
            "name": "supportsSsml",
            "baseName": "supportsSsml",
            "type": "boolean"
        },
        {
            "name": "supportsDisplayText",
            "baseName": "supportsDisplayText",
            "type": "boolean"
        },
        {
            "name": "supportsVoiceInput",
            "baseName": "supportsVoiceInput",
            "type": "boolean"
        },
        {
            "name": "supportsTextInput",
            "baseName": "supportsTextInput",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomAssistantDevice.attributeTypeMap;
    }
}

export class CustomAssistantListItem {
    'id'?: string;
    'title'?: string;
    'description'?: string;
    'image'?: MediaItemModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "MediaItemModel"
        }    ];

    static getAttributeTypeMap() {
        return CustomAssistantListItem.attributeTypeMap;
    }
}

export class CustomAssistantRequestBody {
    'requestId': string;
    'context': CustomAssistantRequestContext;
    'device': CustomAssistantDevice;
    'user': CustomAssistantUser;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "context",
            "baseName": "context",
            "type": "CustomAssistantRequestContext"
        },
        {
            "name": "device",
            "baseName": "device",
            "type": "CustomAssistantDevice"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "CustomAssistantUser"
        }    ];

    static getAttributeTypeMap() {
        return CustomAssistantRequestBody.attributeTypeMap;
    }
}

export class CustomAssistantRequestContext {
    'sessionId': string;
    'noTracking'?: boolean;
    'requestType': string;
    'requestName'?: string;
    'slots'?: { [key: string]: string; };
    'originalInput'?: string;
    'channel': string;
    'requiresLanguageUnderstanding'?: boolean;
    'locale'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sessionId",
            "baseName": "sessionId",
            "type": "string"
        },
        {
            "name": "noTracking",
            "baseName": "noTracking",
            "type": "boolean"
        },
        {
            "name": "requestType",
            "baseName": "requestType",
            "type": "string"
        },
        {
            "name": "requestName",
            "baseName": "requestName",
            "type": "string"
        },
        {
            "name": "slots",
            "baseName": "slots",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "originalInput",
            "baseName": "originalInput",
            "type": "string"
        },
        {
            "name": "channel",
            "baseName": "channel",
            "type": "string"
        },
        {
            "name": "requiresLanguageUnderstanding",
            "baseName": "requiresLanguageUnderstanding",
            "type": "boolean"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomAssistantRequestContext.attributeTypeMap;
    }
}

export class CustomAssistantResponse {
    'responseId'?: string;
    'ssml'?: string;
    'outputSpeech'?: string;
    'displayText'?: string;
    'displayTitle'?: string;
    'responseTemplate'?: string;
    'foregroundImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audioFile'?: MediaItemModel;
    'videoFile'?: MediaItemModel;
    'sessionAttributes'?: { [key: string]: any; };
    'hints'?: Array<string>;
    'listItems'?: Array<CustomAssistantListItem>;
    'endSession'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responseId",
            "baseName": "responseId",
            "type": "string"
        },
        {
            "name": "ssml",
            "baseName": "ssml",
            "type": "string"
        },
        {
            "name": "outputSpeech",
            "baseName": "outputSpeech",
            "type": "string"
        },
        {
            "name": "displayText",
            "baseName": "displayText",
            "type": "string"
        },
        {
            "name": "displayTitle",
            "baseName": "displayTitle",
            "type": "string"
        },
        {
            "name": "responseTemplate",
            "baseName": "responseTemplate",
            "type": "string"
        },
        {
            "name": "foregroundImage",
            "baseName": "foregroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audioFile",
            "baseName": "audioFile",
            "type": "MediaItemModel"
        },
        {
            "name": "videoFile",
            "baseName": "videoFile",
            "type": "MediaItemModel"
        },
        {
            "name": "sessionAttributes",
            "baseName": "sessionAttributes",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "hints",
            "baseName": "hints",
            "type": "Array<string>"
        },
        {
            "name": "listItems",
            "baseName": "listItems",
            "type": "Array<CustomAssistantListItem>"
        },
        {
            "name": "endSession",
            "baseName": "endSession",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomAssistantResponse.attributeTypeMap;
    }
}

export class CustomAssistantUser {
    'id': string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomAssistantUser.attributeTypeMap;
    }
}

export class Device {
    'deviceId'?: string;
    'supportedInterfaces'?: { [key: string]: any; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceId",
            "baseName": "deviceId",
            "type": "string"
        },
        {
            "name": "supportedInterfaces",
            "baseName": "supportedInterfaces",
            "type": "{ [key: string]: any; }"
        }    ];

    static getAttributeTypeMap() {
        return Device.attributeTypeMap;
    }
}

export class DialogflowResponse {
    'fulfillmentText'?: string;
    'fulfillmentMessages'?: Array<FulfillmentMessage>;
    'source'?: string;
    'payload'?: { [key: string]: any; };
    'outputContexts'?: Array<ActionOutputContext>;
    'followupEventInput'?: FollowupEventInput;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fulfillmentText",
            "baseName": "fulfillmentText",
            "type": "string"
        },
        {
            "name": "fulfillmentMessages",
            "baseName": "fulfillmentMessages",
            "type": "Array<FulfillmentMessage>"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "outputContexts",
            "baseName": "outputContexts",
            "type": "Array<ActionOutputContext>"
        },
        {
            "name": "followupEventInput",
            "baseName": "followupEventInput",
            "type": "FollowupEventInput"
        }    ];

    static getAttributeTypeMap() {
        return DialogflowResponse.attributeTypeMap;
    }
}

export class Entity extends null<String, any> {
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Entity.attributeTypeMap);
    }
}

export class FollowupEventInput {
    'name'?: string;
    'languageCode'?: string;
    'parameters'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "languageCode",
            "baseName": "languageCode",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return FollowupEventInput.attributeTypeMap;
    }
}

export class FulfillmentBasicCard {
    'formattedText'?: string;
    'title'?: string;
    'subtitle'?: string;
    'image'?: FulfillmentImage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "formattedText",
            "baseName": "formattedText",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "subtitle",
            "baseName": "subtitle",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "FulfillmentImage"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentBasicCard.attributeTypeMap;
    }
}

export class FulfillmentCard {
    'title'?: string;
    'subtitle'?: string;
    'imageUri'?: string;
    'buttons'?: Array<CardButton>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "subtitle",
            "baseName": "subtitle",
            "type": "string"
        },
        {
            "name": "imageUri",
            "baseName": "imageUri",
            "type": "string"
        },
        {
            "name": "buttons",
            "baseName": "buttons",
            "type": "Array<CardButton>"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentCard.attributeTypeMap;
    }
}

export class FulfillmentCarouselSelect {
    'items'?: Array<ListItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<ListItem>"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentCarouselSelect.attributeTypeMap;
    }
}

export class FulfillmentImage {
    'imageUri'?: string;
    'accessibilityText'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "imageUri",
            "baseName": "imageUri",
            "type": "string"
        },
        {
            "name": "accessibilityText",
            "baseName": "accessibilityText",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentImage.attributeTypeMap;
    }
}

export class FulfillmentListSelect {
    'title'?: string;
    'items'?: Array<ListItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<ListItem>"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentListSelect.attributeTypeMap;
    }
}

export class FulfillmentMessage {
    'platform'?: string;
    'text'?: FulfillmentText;
    'image'?: FulfillmentImage;
    'card'?: FulfillmentCard;
    'basicCard'?: FulfillmentBasicCard;
    'payload'?: any;
    'suggestions'?: FulfillmentSuggestions;
    'listSelect'?: FulfillmentListSelect;
    'carouselSelect'?: FulfillmentCarouselSelect;
    'simpleResponses'?: FulfillmentSimpleResponses;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "platform",
            "baseName": "platform",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "FulfillmentText"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "FulfillmentImage"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "FulfillmentCard"
        },
        {
            "name": "basicCard",
            "baseName": "basicCard",
            "type": "FulfillmentBasicCard"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "any"
        },
        {
            "name": "suggestions",
            "baseName": "suggestions",
            "type": "FulfillmentSuggestions"
        },
        {
            "name": "listSelect",
            "baseName": "listSelect",
            "type": "FulfillmentListSelect"
        },
        {
            "name": "carouselSelect",
            "baseName": "carouselSelect",
            "type": "FulfillmentCarouselSelect"
        },
        {
            "name": "simpleResponses",
            "baseName": "simpleResponses",
            "type": "FulfillmentSimpleResponses"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentMessage.attributeTypeMap;
    }
}

export class FulfillmentSimpleResponses {
    'simpleResponses'?: Array<SimpleResponseItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "simpleResponses",
            "baseName": "simpleResponses",
            "type": "Array<SimpleResponseItem>"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentSimpleResponses.attributeTypeMap;
    }
}

export class FulfillmentSuggestions {
    'suggestions'?: Array<Suggestion>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "suggestions",
            "baseName": "suggestions",
            "type": "Array<Suggestion>"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentSuggestions.attributeTypeMap;
    }
}

export class FulfillmentText {
    'text'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "text",
            "baseName": "text",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentText.attributeTypeMap;
    }
}

export class Geolocation {
    'locationServices'?: LocationServices;
    'timestamp'?: Date;
    'coordinate'?: GeolocationCoordinate;
    'altitude'?: GeolocationAltitude;
    'heading'?: GeolocationHeading;
    'speed'?: GeolocationSpeed;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationServices",
            "baseName": "locationServices",
            "type": "LocationServices"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        },
        {
            "name": "coordinate",
            "baseName": "coordinate",
            "type": "GeolocationCoordinate"
        },
        {
            "name": "altitude",
            "baseName": "altitude",
            "type": "GeolocationAltitude"
        },
        {
            "name": "heading",
            "baseName": "heading",
            "type": "GeolocationHeading"
        },
        {
            "name": "speed",
            "baseName": "speed",
            "type": "GeolocationSpeed"
        }    ];

    static getAttributeTypeMap() {
        return Geolocation.attributeTypeMap;
    }
}

export class GeolocationAltitude {
    'altitudeInMeters'?: number;
    'accuracyInMeters'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "altitudeInMeters",
            "baseName": "altitudeInMeters",
            "type": "number"
        },
        {
            "name": "accuracyInMeters",
            "baseName": "accuracyInMeters",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GeolocationAltitude.attributeTypeMap;
    }
}

export class GeolocationCoordinate {
    'latitudeInDegrees'?: number;
    'longitudeInDegrees'?: number;
    'accuracyInMeters'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "latitudeInDegrees",
            "baseName": "latitudeInDegrees",
            "type": "number"
        },
        {
            "name": "longitudeInDegrees",
            "baseName": "longitudeInDegrees",
            "type": "number"
        },
        {
            "name": "accuracyInMeters",
            "baseName": "accuracyInMeters",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GeolocationCoordinate.attributeTypeMap;
    }
}

export class GeolocationHeading {
    'directionInDegrees'?: number;
    'accuracyInDegrees'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "directionInDegrees",
            "baseName": "directionInDegrees",
            "type": "number"
        },
        {
            "name": "accuracyInDegrees",
            "baseName": "accuracyInDegrees",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GeolocationHeading.attributeTypeMap;
    }
}

export class GeolocationSpeed {
    'speedInMetersPerSecond'?: number;
    'accuracyInMetresPerSecond'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "speedInMetersPerSecond",
            "baseName": "speedInMetersPerSecond",
            "type": "number"
        },
        {
            "name": "accuracyInMetresPerSecond",
            "baseName": "accuracyInMetresPerSecond",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GeolocationSpeed.attributeTypeMap;
    }
}

export class ICard {
    'type': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ICard.attributeTypeMap;
    }
}

export class IDirective {
    'type': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IDirective.attributeTypeMap;
    }
}

export class IOutputSpeech {
    'type': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IOutputSpeech.attributeTypeMap;
    }
}

export class ListItem {
    'info'?: ListItemInfo;
    'title'?: string;
    'description'?: string;
    'image'?: FulfillmentImage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "info",
            "baseName": "info",
            "type": "ListItemInfo"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "FulfillmentImage"
        }    ];

    static getAttributeTypeMap() {
        return ListItem.attributeTypeMap;
    }
}

export class ListItemInfo {
    'key'?: string;
    'synonyms'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "synonyms",
            "baseName": "synonyms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ListItemInfo.attributeTypeMap;
    }
}

export class LocationServices {
    'access'?: LocationServices.AccessEnum;
    'status'?: LocationServices.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "access",
            "baseName": "access",
            "type": "LocationServices.AccessEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "LocationServices.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return LocationServices.attributeTypeMap;
    }
}

export namespace LocationServices {
    export enum AccessEnum {
        ENABLED = <any> 'ENABLED',
        DISABLED = <any> 'DISABLED'
    }
    export enum StatusEnum {
        RUNNING = <any> 'RUNNING',
        STOPPED = <any> 'STOPPED'
    }
}
export class MediaItemModel {
    'id'?: string;
    'name'?: string;
    'url'?: string;
    'fileExtension'?: string;
    'mediaType'?: string;
    'applicationId'?: string;
    'modifiedDate'?: Date;
    'caption'?: string;
    'isDisabled'?: boolean;
    'modifiedByUserId'?: string;
    'createdFromId'?: string;
    'modifiedByUser'?: UserModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "fileExtension",
            "baseName": "fileExtension",
            "type": "string"
        },
        {
            "name": "mediaType",
            "baseName": "mediaType",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "caption",
            "baseName": "caption",
            "type": "string"
        },
        {
            "name": "isDisabled",
            "baseName": "isDisabled",
            "type": "boolean"
        },
        {
            "name": "modifiedByUserId",
            "baseName": "modifiedByUserId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "modifiedByUser",
            "baseName": "modifiedByUser",
            "type": "UserModel"
        }    ];

    static getAttributeTypeMap() {
        return MediaItemModel.attributeTypeMap;
    }
}

export class MessageReaction {
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MessageReaction.attributeTypeMap;
    }
}

export class OriginalDetectIntentRequest {
    'source'?: string;
    'version'?: string;
    'payload'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return OriginalDetectIntentRequest.attributeTypeMap;
    }
}

export class Permissions {
    'consentToken'?: string;
    'scopes'?: { [key: string]: Scope; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "consentToken",
            "baseName": "consentToken",
            "type": "string"
        },
        {
            "name": "scopes",
            "baseName": "scopes",
            "type": "{ [key: string]: Scope; }"
        }    ];

    static getAttributeTypeMap() {
        return Permissions.attributeTypeMap;
    }
}

export class PlaybackState {
    'token'?: string;
    'offsetInMilliseconds'?: number;
    'playerActivity'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "offsetInMilliseconds",
            "baseName": "offsetInMilliseconds",
            "type": "number"
        },
        {
            "name": "playerActivity",
            "baseName": "playerActivity",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PlaybackState.attributeTypeMap;
    }
}

export class Reprompt {
    'outputSpeech'?: IOutputSpeech;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "outputSpeech",
            "baseName": "outputSpeech",
            "type": "IOutputSpeech"
        }    ];

    static getAttributeTypeMap() {
        return Reprompt.attributeTypeMap;
    }
}

export class Request {
    'type'?: string;
    'requestId'?: string;
    'locale'?: string;
    'timestamp'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Request.attributeTypeMap;
    }
}

export class ResponseBody {
    'outputSpeech'?: IOutputSpeech;
    'card'?: ICard;
    'reprompt'?: Reprompt;
    'shouldEndSession'?: boolean;
    'directives'?: Array<IDirective>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "outputSpeech",
            "baseName": "outputSpeech",
            "type": "IOutputSpeech"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "ICard"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "Reprompt"
        },
        {
            "name": "shouldEndSession",
            "baseName": "shouldEndSession",
            "type": "boolean"
        },
        {
            "name": "directives",
            "baseName": "directives",
            "type": "Array<IDirective>"
        }    ];

    static getAttributeTypeMap() {
        return ResponseBody.attributeTypeMap;
    }
}

export class Scope {
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Scope.attributeTypeMap;
    }
}

export class SemanticAction {
    'id'?: string;
    'entities'?: { [key: string]: Entity; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "entities",
            "baseName": "entities",
            "type": "{ [key: string]: Entity; }"
        }    ];

    static getAttributeTypeMap() {
        return SemanticAction.attributeTypeMap;
    }
}

export class Session {
    '_new'?: boolean;
    'sessionId'?: string;
    'attributes'?: { [key: string]: any; };
    'application'?: Application;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_new",
            "baseName": "new",
            "type": "boolean"
        },
        {
            "name": "sessionId",
            "baseName": "sessionId",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "application",
            "baseName": "application",
            "type": "Application"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return Session.attributeTypeMap;
    }
}

export class SimpleResponseItem {
    'textToSpeech'?: string;
    'ssml'?: string;
    'displayText'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "textToSpeech",
            "baseName": "textToSpeech",
            "type": "string"
        },
        {
            "name": "ssml",
            "baseName": "ssml",
            "type": "string"
        },
        {
            "name": "displayText",
            "baseName": "displayText",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SimpleResponseItem.attributeTypeMap;
    }
}

export class SkillResponse {
    'version': string;
    'sessionAttributes'?: { [key: string]: any; };
    'response': ResponseBody;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "sessionAttributes",
            "baseName": "sessionAttributes",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "response",
            "baseName": "response",
            "type": "ResponseBody"
        }    ];

    static getAttributeTypeMap() {
        return SkillResponse.attributeTypeMap;
    }
}

export class SuggestedActions {
    'to'?: Array<string>;
    'actions'?: Array<CardAction>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<string>"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<CardAction>"
        }    ];

    static getAttributeTypeMap() {
        return SuggestedActions.attributeTypeMap;
    }
}

export class Suggestion {
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Suggestion.attributeTypeMap;
    }
}

export class TextHighlight {
    'text'?: string;
    'occurrence'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "occurrence",
            "baseName": "occurrence",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TextHighlight.attributeTypeMap;
    }
}

export class User {
    'userId'?: string;
    'accessToken'?: string;
    'permissions'?: Permissions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "Permissions"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class UserModel {
    'id'?: string;
    'email'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'isAdmin'?: boolean;
    'imageUrl'?: string;
    'isApiUser'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "isApiUser",
            "baseName": "isApiUser",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserModel.attributeTypeMap;
    }
}

export class VideoSupport {
    'codecs'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "codecs",
            "baseName": "codecs",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return VideoSupport.attributeTypeMap;
    }
}

export class ViewportExperience {
    'canResize'?: boolean;
    'canRotate'?: boolean;
    'arcMinuteWidth'?: number;
    'arcMinuteHeight'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canResize",
            "baseName": "canResize",
            "type": "boolean"
        },
        {
            "name": "canRotate",
            "baseName": "canRotate",
            "type": "boolean"
        },
        {
            "name": "arcMinuteWidth",
            "baseName": "arcMinuteWidth",
            "type": "number"
        },
        {
            "name": "arcMinuteHeight",
            "baseName": "arcMinuteHeight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ViewportExperience.attributeTypeMap;
    }
}

export class VivContext {
    'clientAppVersion'?: string;
    'is24HourFormat'?: boolean;
    'timezone'?: string;
    'handsFree'?: boolean;
    'screenLocked'?: boolean;
    'sessionId'?: string;
    'locale'?: string;
    'grantedPermissions'?: any;
    'clientAppId'?: string;
    'device'?: string;
    'userId'?: string;
    'canTypeId'?: string;
    'bixbyUserId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientAppVersion",
            "baseName": "clientAppVersion",
            "type": "string"
        },
        {
            "name": "is24HourFormat",
            "baseName": "is24HourFormat",
            "type": "boolean"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "handsFree",
            "baseName": "handsFree",
            "type": "boolean"
        },
        {
            "name": "screenLocked",
            "baseName": "screenLocked",
            "type": "boolean"
        },
        {
            "name": "sessionId",
            "baseName": "sessionId",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "grantedPermissions",
            "baseName": "grantedPermissions",
            "type": "any"
        },
        {
            "name": "clientAppId",
            "baseName": "clientAppId",
            "type": "string"
        },
        {
            "name": "device",
            "baseName": "device",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "canTypeId",
            "baseName": "canTypeId",
            "type": "string"
        },
        {
            "name": "bixbyUserId",
            "baseName": "bixbyUserId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VivContext.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "AlexaViewport.ShapeEnum": AlexaViewport.ShapeEnum,
        "LocationServices.AccessEnum": LocationServices.AccessEnum,
        "LocationServices.StatusEnum": LocationServices.StatusEnum,
}

let typeMap: {[index: string]: any} = {
    "APLContext": APLContext,
    "APLSkillRequest": APLSkillRequest,
    "ActionIntent": ActionIntent,
    "ActionOutputContext": ActionOutputContext,
    "ActionQueryResult": ActionQueryResult,
    "ActionRequest": ActionRequest,
    "Activity": Activity,
    "AlexaDisplay": AlexaDisplay,
    "AlexaSystem": AlexaSystem,
    "AlexaViewport": AlexaViewport,
    "Application": Application,
    "Attachment": Attachment,
    "BixbyActionRequest": BixbyActionRequest,
    "BixbyEventSearchRequest": BixbyEventSearchRequest,
    "BixbyGeneralQuestionRequest": BixbyGeneralQuestionRequest,
    "BixbyGoToStepRequest": BixbyGoToStepRequest,
    "BixbyItemSelectedRequest": BixbyItemSelectedRequest,
    "BixbyLatestMessageRequest": BixbyLatestMessageRequest,
    "BixbyListItem": BixbyListItem,
    "BixbyNumberRequest": BixbyNumberRequest,
    "BixbyRecipeSearchRequest": BixbyRecipeSearchRequest,
    "BixbyResponse": BixbyResponse,
    "CardAction": CardAction,
    "CardButton": CardButton,
    "ChannelAccount": ChannelAccount,
    "ConversationAccount": ConversationAccount,
    "ConversationReference": ConversationReference,
    "ConversationSessionState": ConversationSessionState,
    "CustomAssistantDevice": CustomAssistantDevice,
    "CustomAssistantListItem": CustomAssistantListItem,
    "CustomAssistantRequestBody": CustomAssistantRequestBody,
    "CustomAssistantRequestContext": CustomAssistantRequestContext,
    "CustomAssistantResponse": CustomAssistantResponse,
    "CustomAssistantUser": CustomAssistantUser,
    "Device": Device,
    "DialogflowResponse": DialogflowResponse,
    "Entity": Entity,
    "FollowupEventInput": FollowupEventInput,
    "FulfillmentBasicCard": FulfillmentBasicCard,
    "FulfillmentCard": FulfillmentCard,
    "FulfillmentCarouselSelect": FulfillmentCarouselSelect,
    "FulfillmentImage": FulfillmentImage,
    "FulfillmentListSelect": FulfillmentListSelect,
    "FulfillmentMessage": FulfillmentMessage,
    "FulfillmentSimpleResponses": FulfillmentSimpleResponses,
    "FulfillmentSuggestions": FulfillmentSuggestions,
    "FulfillmentText": FulfillmentText,
    "Geolocation": Geolocation,
    "GeolocationAltitude": GeolocationAltitude,
    "GeolocationCoordinate": GeolocationCoordinate,
    "GeolocationHeading": GeolocationHeading,
    "GeolocationSpeed": GeolocationSpeed,
    "ICard": ICard,
    "IDirective": IDirective,
    "IOutputSpeech": IOutputSpeech,
    "ListItem": ListItem,
    "ListItemInfo": ListItemInfo,
    "LocationServices": LocationServices,
    "MediaItemModel": MediaItemModel,
    "MessageReaction": MessageReaction,
    "OriginalDetectIntentRequest": OriginalDetectIntentRequest,
    "Permissions": Permissions,
    "PlaybackState": PlaybackState,
    "Reprompt": Reprompt,
    "Request": Request,
    "ResponseBody": ResponseBody,
    "Scope": Scope,
    "SemanticAction": SemanticAction,
    "Session": Session,
    "SimpleResponseItem": SimpleResponseItem,
    "SkillResponse": SkillResponse,
    "SuggestedActions": SuggestedActions,
    "Suggestion": Suggestion,
    "TextHighlight": TextHighlight,
    "User": User,
    "UserModel": UserModel,
    "VideoSupport": VideoSupport,
    "ViewportExperience": ViewportExperience,
    "VivContext": VivContext,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AlexaApiApiKeys {
    Bearer,
}

export class AlexaApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AlexaApiApiKeys, value: string) {
        (this.authentications as any)[AlexaApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Handles an unsigned request from Alexa. This endpoint can be used from existing skills without validating Alexa certificates.
     * @param applicationId 
     * @param applicationSecret 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public handleLocalRequest (applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SkillResponse;  }> {
        const localVarPath = this.basePath + '/api/Alexa/HandleRequest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "APLSkillRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SkillResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SkillResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Handles a signed request from Alexa. This endpoint validates the certificates coming from amazon and the skill id sent.
     * @param applicationId 
     * @param applicationSecret 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public handleSignedRequest (applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SkillResponse;  }> {
        const localVarPath = this.basePath + '/api/Alexa/HandleSignedRequest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "APLSkillRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SkillResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SkillResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BixbyApiApiKeys {
    Bearer,
}

export class BixbyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BixbyApiApiKeys, value: string) {
        (this.authentications as any)[BixbyApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param actionName 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleCustomRequest (actionName: string, applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/Custom/{actionName}'
            .replace('{' + 'actionName' + '}', encodeURIComponent(String(actionName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'actionName' is not null or undefined
        if (actionName === null || actionName === undefined) {
            throw new Error('Required parameter actionName was null or undefined when calling handleCustomRequest.');
        }

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleDynamicRequest (applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/Dynamic';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyGeneralQuestionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleEventGeneralSearchRequest (applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/EventGeneralSearch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyEventSearchRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleEventLocationSearchRequest (applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/EventLocationSearch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyEventSearchRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleEventStartTimeSearchRequest (applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/EventStartTimeSearch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyEventSearchRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleEventStatusSearchRequest (applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/EventStatusSearch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyEventSearchRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleGeneralQuestionRequest (applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/GeneralQuestion';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyGeneralQuestionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleGoToStepRequest (applicationId?: string, applicationSecret?: string, model?: BixbyGoToStepRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/GoToStep';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyGoToStepRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleHelpRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/Help';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleLatestMessageRequest (applicationId?: string, applicationSecret?: string, model?: BixbyLatestMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/LatestMessage';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyLatestMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleListItemSelectRequest (applicationId?: string, applicationSecret?: string, model?: BixbyItemSelectedRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/ListItemSelect';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyItemSelectedRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleMoreRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/More';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleNextRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/Next';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleNoRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/No';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleNumberRequest (applicationId?: string, applicationSecret?: string, model?: BixbyNumberRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/Number';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyNumberRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handlePrevisousRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/Previous';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleRecipeDetailsRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/RecipeDetails';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleRecipeSearchRequest (applicationId?: string, applicationSecret?: string, model?: BixbyRecipeSearchRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/RecipeSearch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyRecipeSearchRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleStartOverRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/StartOver';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleStartRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/Start';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleStopRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/Stop';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleWelcomeRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/Welcome';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleYesRequest (applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }> {
        const localVarPath = this.basePath + '/api/Bixby/HandleRequest/Yes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BixbyActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BixbyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BixbyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BotServiceApiApiKeys {
    Bearer,
}

export class BotServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BotServiceApiApiKeys, value: string) {
        (this.authentications as any)[BotServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Used for getting the direct activity response rather than having it posted to a full bot service.  This endpoint is useful for testing scenarios as well as adding voicify on top of existing bot framework  servers
     * @param applicationId 
     * @param applicationSecret 
     * @param activity 
     * @param {*} [options] Override http request options.
     */
    public handleActivityRequest (applicationId?: string, applicationSecret?: string, activity?: Activity, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/BotService/HandleActivityRequest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(activity, "Activity")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Used for handling full Azure Bot Service requests. This endpoint validates against your MS app ID and Secret and will POST back to the activity's channel with no return type.
     * @param applicationId 
     * @param applicationSecret 
     * @param nluTool 
     * @param {*} [options] Override http request options.
     */
    public handleRequest (applicationId?: string, applicationSecret?: string, nluTool?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/BotService/HandleRequest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        if (nluTool !== undefined) {
            localVarQueryParameters['nluTool'] = ObjectSerializer.serialize(nluTool, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomAssistantApiApiKeys {
    Bearer,
}

export class CustomAssistantApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomAssistantApiApiKeys, value: string) {
        (this.authentications as any)[CustomAssistantApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Handles requests from a custom assistant. You can optionally pass in pre-processed and aligned NLU data or let Voicify handle it behind the scenes.
     * @param applicationId 
     * @param applicationSecret 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public handleRequest (applicationId?: string, applicationSecret?: string, model?: CustomAssistantRequestBody, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomAssistantResponse;  }> {
        const localVarPath = this.basePath + '/api/CustomAssistant/HandleRequest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CustomAssistantRequestBody")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomAssistantResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomAssistantResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DialogflowApiApiKeys {
    Bearer,
}

export class DialogflowApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DialogflowApiApiKeys, value: string) {
        (this.authentications as any)[DialogflowApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Handles a webhook fulfillment request from dialogflow and returns a dialogflow structured response
     * @param applicationId 
     * @param applicationSecret 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public handleRequest (applicationId?: string, applicationSecret?: string, request?: ActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DialogflowResponse;  }> {
        const localVarPath = this.basePath + '/api/Dialogflow/HandleRequest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "ActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DialogflowResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DialogflowResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GoogleAssistantApiApiKeys {
    Bearer,
}

export class GoogleAssistantApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GoogleAssistantApiApiKeys, value: string) {
        (this.authentications as any)[GoogleAssistantApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deprecated - use Dialogflow endpoints
     * @param applicationId 
     * @param applicationSecret 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public handleRequest (applicationId?: string, applicationSecret?: string, request?: ActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/GoogleAssistant/HandleRequest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "ActionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HealthCheckApiApiKeys {
    Bearer,
}

export class HealthCheckApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HealthCheckApiApiKeys, value: string) {
        (this.authentications as any)[HealthCheckApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public healthCheck (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/HealthCheck';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserProfileApiApiKeys {
    Bearer,
}

export class UserProfileApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserProfileApiApiKeys, value: string) {
        (this.authentications as any)[UserProfileApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Gets the current session state data
     * @param sessionId 
     * @param applicationId 
     * @param applicationSecret 
     * @param {*} [options] Override http request options.
     */
    public getSessionAttributes (sessionId: string, applicationId?: string, applicationSecret?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConversationSessionState;  }> {
        const localVarPath = this.basePath + '/api/UserProfile/session/{sessionId}'
            .replace('{' + 'sessionId' + '}', encodeURIComponent(String(sessionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sessionId' is not null or undefined
        if (sessionId === null || sessionId === undefined) {
            throw new Error('Required parameter sessionId was null or undefined when calling getSessionAttributes.');
        }

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (applicationSecret !== undefined) {
            localVarQueryParameters['applicationSecret'] = ObjectSerializer.serialize(applicationSecret, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConversationSessionState;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConversationSessionState");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
