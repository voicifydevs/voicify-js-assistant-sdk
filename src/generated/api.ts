/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Voicify Assistant API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: V1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface APLContext
 */
export interface APLContext {
    /**
     * 
     * @type {AlexaDisplay}
     * @memberof APLContext
     */
    display?: AlexaDisplay;
    /**
     * 
     * @type {AlexaViewport}
     * @memberof APLContext
     */
    viewport?: AlexaViewport;
    /**
     * 
     * @type {AlexaSystem}
     * @memberof APLContext
     */
    system?: AlexaSystem;
    /**
     * 
     * @type {PlaybackState}
     * @memberof APLContext
     */
    audioPlayer?: PlaybackState;
    /**
     * 
     * @type {Geolocation}
     * @memberof APLContext
     */
    geolocation?: Geolocation;
}

/**
 * 
 * @export
 * @interface APLSkillRequest
 */
export interface APLSkillRequest {
    /**
     * 
     * @type {APLContext}
     * @memberof APLSkillRequest
     */
    context?: APLContext;
    /**
     * 
     * @type {string}
     * @memberof APLSkillRequest
     */
    version?: string;
    /**
     * 
     * @type {Session}
     * @memberof APLSkillRequest
     */
    session?: Session;
    /**
     * 
     * @type {Request}
     * @memberof APLSkillRequest
     */
    request?: Request;
}

/**
 * 
 * @export
 * @interface ActionIntent
 */
export interface ActionIntent {
    /**
     * 
     * @type {string}
     * @memberof ActionIntent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionIntent
     */
    displayName?: string;
}

/**
 * 
 * @export
 * @interface ActionOutputContext
 */
export interface ActionOutputContext {
    /**
     * 
     * @type {string}
     * @memberof ActionOutputContext
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ActionOutputContext
     */
    lifespanCount?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ActionOutputContext
     */
    parameters?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface ActionQueryResult
 */
export interface ActionQueryResult {
    /**
     * 
     * @type {string}
     * @memberof ActionQueryResult
     */
    queryText?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionQueryResult
     */
    action?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ActionQueryResult
     */
    parameters?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ActionQueryResult
     */
    allRequiredParamsPresent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ActionQueryResult
     */
    fulfillmentText?: string;
    /**
     * 
     * @type {Array<FulfillmentMessage>}
     * @memberof ActionQueryResult
     */
    fulfillmentMessages?: Array<FulfillmentMessage>;
    /**
     * 
     * @type {Array<ActionOutputContext>}
     * @memberof ActionQueryResult
     */
    outputContexts?: Array<ActionOutputContext>;
    /**
     * 
     * @type {ActionIntent}
     * @memberof ActionQueryResult
     */
    intent?: ActionIntent;
    /**
     * 
     * @type {number}
     * @memberof ActionQueryResult
     */
    intentDetectionConfidence?: number;
    /**
     * 
     * @type {any}
     * @memberof ActionQueryResult
     */
    diagnosticInfo?: any;
    /**
     * 
     * @type {string}
     * @memberof ActionQueryResult
     */
    languageCode?: string;
}

/**
 * 
 * @export
 * @interface ActionRequest
 */
export interface ActionRequest {
    /**
     * 
     * @type {string}
     * @memberof ActionRequest
     */
    responseId?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionRequest
     */
    session?: string;
    /**
     * 
     * @type {ActionQueryResult}
     * @memberof ActionRequest
     */
    queryResult?: ActionQueryResult;
    /**
     * 
     * @type {OriginalDetectIntentRequest}
     * @memberof ActionRequest
     */
    originalDetectIntentRequest?: OriginalDetectIntentRequest;
}

/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof Activity
     */
    timestamp?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Activity
     */
    localTimestamp?: Date;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    localTimezone?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    serviceUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    channelId?: string;
    /**
     * 
     * @type {ChannelAccount}
     * @memberof Activity
     */
    from?: ChannelAccount;
    /**
     * 
     * @type {ConversationAccount}
     * @memberof Activity
     */
    conversation?: ConversationAccount;
    /**
     * 
     * @type {ChannelAccount}
     * @memberof Activity
     */
    recipient?: ChannelAccount;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    textFormat?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    attachmentLayout?: string;
    /**
     * 
     * @type {Array<ChannelAccount>}
     * @memberof Activity
     */
    membersAdded?: Array<ChannelAccount>;
    /**
     * 
     * @type {Array<ChannelAccount>}
     * @memberof Activity
     */
    membersRemoved?: Array<ChannelAccount>;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof Activity
     */
    reactionsAdded?: Array<MessageReaction>;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof Activity
     */
    reactionsRemoved?: Array<MessageReaction>;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    topicName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Activity
     */
    historyDisclosed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    locale?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    text?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    speak?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    inputHint?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    summary?: string;
    /**
     * 
     * @type {SuggestedActions}
     * @memberof Activity
     */
    suggestedActions?: SuggestedActions;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof Activity
     */
    attachments?: Array<Attachment>;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof Activity
     */
    entities?: Array<Entity>;
    /**
     * 
     * @type {any}
     * @memberof Activity
     */
    channelData?: any;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    action?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    replyToId?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    valueType?: string;
    /**
     * 
     * @type {any}
     * @memberof Activity
     */
    value?: any;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    name?: string;
    /**
     * 
     * @type {ConversationReference}
     * @memberof Activity
     */
    relatesTo?: ConversationReference;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    code?: string;
    /**
     * 
     * @type {Date}
     * @memberof Activity
     */
    expiration?: Date;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    importance?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    deliveryMode?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Activity
     */
    listenFor?: Array<string>;
    /**
     * 
     * @type {Array<TextHighlight>}
     * @memberof Activity
     */
    textHighlights?: Array<TextHighlight>;
    /**
     * 
     * @type {SemanticAction}
     * @memberof Activity
     */
    semanticAction?: SemanticAction;
}

/**
 * 
 * @export
 * @interface AlexaDisplay
 */
export interface AlexaDisplay {
    /**
     * 
     * @type {string}
     * @memberof AlexaDisplay
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface AlexaSystem
 */
export interface AlexaSystem {
    /**
     * 
     * @type {string}
     * @memberof AlexaSystem
     */
    apiAccessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof AlexaSystem
     */
    apiEndpoint?: string;
    /**
     * 
     * @type {Application}
     * @memberof AlexaSystem
     */
    application?: Application;
    /**
     * 
     * @type {User}
     * @memberof AlexaSystem
     */
    user?: User;
    /**
     * 
     * @type {Device}
     * @memberof AlexaSystem
     */
    device?: Device;
}

/**
 * 
 * @export
 * @interface AlexaViewport
 */
export interface AlexaViewport {
    /**
     * 
     * @type {Array<ViewportExperience>}
     * @memberof AlexaViewport
     */
    experiences?: Array<ViewportExperience>;
    /**
     * 
     * @type {number}
     * @memberof AlexaViewport
     */
    currentPixelWidth?: number;
    /**
     * 
     * @type {number}
     * @memberof AlexaViewport
     */
    currentPixelHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof AlexaViewport
     */
    dpi?: number;
    /**
     * 
     * @type {number}
     * @memberof AlexaViewport
     */
    pixelHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof AlexaViewport
     */
    pixelWidth?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlexaViewport
     */
    touch?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlexaViewport
     */
    keyboard?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AlexaViewport
     */
    shape?: AlexaViewport.ShapeEnum;
    /**
     * 
     * @type {VideoSupport}
     * @memberof AlexaViewport
     */
    video?: VideoSupport;
}

/**
 * @export
 * @namespace AlexaViewport
 */
export namespace AlexaViewport {
    /**
     * @export
     * @enum {string}
     */
    export enum ShapeEnum {
        SQUARE = <any> 'SQUARE',
        RECTANGLE = <any> 'RECTANGLE',
        ROUND = <any> 'ROUND'
    }
}

/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    applicationId?: string;
}

/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    contentType?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    contentUrl?: string;
    /**
     * 
     * @type {any}
     * @memberof Attachment
     */
    content?: any;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    thumbnailUrl?: string;
}

/**
 * 
 * @export
 * @interface BixbyActionRequest
 */
export interface BixbyActionRequest {
    [key: string]: any | any;

    /**
     * 
     * @type {VivContext}
     * @memberof BixbyActionRequest
     */
    vivContext?: VivContext;
}

/**
 * 
 * @export
 * @interface BixbyEventSearchRequest
 */
export interface BixbyEventSearchRequest {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof BixbyEventSearchRequest
     */
    eventName?: string;
    /**
     * 
     * @type {string}
     * @memberof BixbyEventSearchRequest
     */
    locationName?: string;
    /**
     * 
     * @type {Date}
     * @memberof BixbyEventSearchRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BixbyEventSearchRequest
     */
    startTime?: Date;
    /**
     * 
     * @type {VivContext}
     * @memberof BixbyEventSearchRequest
     */
    vivContext?: VivContext;
}

/**
 * 
 * @export
 * @interface BixbyGeneralQuestionRequest
 */
export interface BixbyGeneralQuestionRequest {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof BixbyGeneralQuestionRequest
     */
    voicifyQuery?: string;
    /**
     * 
     * @type {VivContext}
     * @memberof BixbyGeneralQuestionRequest
     */
    vivContext?: VivContext;
}

/**
 * 
 * @export
 * @interface BixbyGoToStepRequest
 */
export interface BixbyGoToStepRequest {
    [key: string]: any | any;

    /**
     * 
     * @type {number}
     * @memberof BixbyGoToStepRequest
     */
    stepNumber?: number;
    /**
     * 
     * @type {VivContext}
     * @memberof BixbyGoToStepRequest
     */
    vivContext?: VivContext;
}

/**
 * 
 * @export
 * @interface BixbyItemSelectedRequest
 */
export interface BixbyItemSelectedRequest {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof BixbyItemSelectedRequest
     */
    itemId?: string;
    /**
     * 
     * @type {VivContext}
     * @memberof BixbyItemSelectedRequest
     */
    vivContext?: VivContext;
}

/**
 * 
 * @export
 * @interface BixbyLatestMessageRequest
 */
export interface BixbyLatestMessageRequest {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof BixbyLatestMessageRequest
     */
    latestMessageCategory?: string;
    /**
     * 
     * @type {VivContext}
     * @memberof BixbyLatestMessageRequest
     */
    vivContext?: VivContext;
}

/**
 * 
 * @export
 * @interface BixbyListItem
 */
export interface BixbyListItem {
    /**
     * 
     * @type {string}
     * @memberof BixbyListItem
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BixbyListItem
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof BixbyListItem
     */
    description?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof BixbyListItem
     */
    image?: MediaItemModel;
}

/**
 * 
 * @export
 * @interface BixbyNumberRequest
 */
export interface BixbyNumberRequest {
    [key: string]: any | any;

    /**
     * 
     * @type {number}
     * @memberof BixbyNumberRequest
     */
    number?: number;
    /**
     * 
     * @type {VivContext}
     * @memberof BixbyNumberRequest
     */
    vivContext?: VivContext;
}

/**
 * 
 * @export
 * @interface BixbyRecipeSearchRequest
 */
export interface BixbyRecipeSearchRequest {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof BixbyRecipeSearchRequest
     */
    recipeName?: string;
    /**
     * 
     * @type {string}
     * @memberof BixbyRecipeSearchRequest
     */
    ingredientName?: string;
    /**
     * 
     * @type {string}
     * @memberof BixbyRecipeSearchRequest
     */
    mealType?: string;
    /**
     * 
     * @type {Date}
     * @memberof BixbyRecipeSearchRequest
     */
    cookTime?: Date;
    /**
     * 
     * @type {VivContext}
     * @memberof BixbyRecipeSearchRequest
     */
    vivContext?: VivContext;
}

/**
 * 
 * @export
 * @interface BixbyResponse
 */
export interface BixbyResponse {
    /**
     * 
     * @type {string}
     * @memberof BixbyResponse
     */
    responseId?: string;
    /**
     * 
     * @type {string}
     * @memberof BixbyResponse
     */
    ssml?: string;
    /**
     * 
     * @type {string}
     * @memberof BixbyResponse
     */
    outputSpeech?: string;
    /**
     * 
     * @type {string}
     * @memberof BixbyResponse
     */
    displayText?: string;
    /**
     * 
     * @type {string}
     * @memberof BixbyResponse
     */
    displayTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof BixbyResponse
     */
    responseTemplate?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof BixbyResponse
     */
    foregroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof BixbyResponse
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof BixbyResponse
     */
    audioFile?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof BixbyResponse
     */
    videoFile?: MediaItemModel;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BixbyResponse
     */
    sessionAttributes?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof BixbyResponse
     */
    hints?: Array<string>;
    /**
     * 
     * @type {Array<BixbyListItem>}
     * @memberof BixbyResponse
     */
    listItems?: Array<BixbyListItem>;
}

/**
 * 
 * @export
 * @interface CardAction
 */
export interface CardAction {
    /**
     * 
     * @type {string}
     * @memberof CardAction
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAction
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAction
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAction
     */
    text?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAction
     */
    displayText?: string;
    /**
     * 
     * @type {any}
     * @memberof CardAction
     */
    value?: any;
    /**
     * 
     * @type {any}
     * @memberof CardAction
     */
    channelData?: any;
}

/**
 * 
 * @export
 * @interface CardButton
 */
export interface CardButton {
    /**
     * 
     * @type {string}
     * @memberof CardButton
     */
    text?: string;
    /**
     * 
     * @type {string}
     * @memberof CardButton
     */
    postback?: string;
}

/**
 * 
 * @export
 * @interface ChannelAccount
 */
export interface ChannelAccount {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof ChannelAccount
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelAccount
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelAccount
     */
    aadObjectId?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelAccount
     */
    role?: string;
}

/**
 * 
 * @export
 * @interface ConversationAccount
 */
export interface ConversationAccount {
    [key: string]: any | any;

    /**
     * 
     * @type {boolean}
     * @memberof ConversationAccount
     */
    isGroup?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConversationAccount
     */
    conversationType?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationAccount
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationAccount
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationAccount
     */
    aadObjectId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationAccount
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationAccount
     */
    tenantId?: string;
}

/**
 * 
 * @export
 * @interface ConversationReference
 */
export interface ConversationReference {
    /**
     * 
     * @type {string}
     * @memberof ConversationReference
     */
    activityId?: string;
    /**
     * 
     * @type {ChannelAccount}
     * @memberof ConversationReference
     */
    user?: ChannelAccount;
    /**
     * 
     * @type {ChannelAccount}
     * @memberof ConversationReference
     */
    bot?: ChannelAccount;
    /**
     * 
     * @type {ConversationAccount}
     * @memberof ConversationReference
     */
    conversation?: ConversationAccount;
    /**
     * 
     * @type {string}
     * @memberof ConversationReference
     */
    channelId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationReference
     */
    serviceUrl?: string;
}

/**
 * 
 * @export
 * @interface ConversationSessionState
 */
export interface ConversationSessionState {
    /**
     * 
     * @type {string}
     * @memberof ConversationSessionState
     */
    id?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConversationSessionState
     */
    sessionAttributes?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface CustomAssistantDevice
 */
export interface CustomAssistantDevice {
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantDevice
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantDevice
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantDevice
     */
    supportsVideo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantDevice
     */
    supportsForegroundImage?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantDevice
     */
    supportsBackgroundImage?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantDevice
     */
    supportsAudio?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantDevice
     */
    supportsSsml?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantDevice
     */
    supportsDisplayText?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantDevice
     */
    supportsVoiceInput?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantDevice
     */
    supportsTextInput?: boolean;
}

/**
 * 
 * @export
 * @interface CustomAssistantListItem
 */
export interface CustomAssistantListItem {
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantListItem
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantListItem
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantListItem
     */
    description?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof CustomAssistantListItem
     */
    image?: MediaItemModel;
}

/**
 * 
 * @export
 * @interface CustomAssistantRequestBody
 */
export interface CustomAssistantRequestBody {
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantRequestBody
     */
    requestId: string;
    /**
     * 
     * @type {CustomAssistantRequestContext}
     * @memberof CustomAssistantRequestBody
     */
    context: CustomAssistantRequestContext;
    /**
     * 
     * @type {CustomAssistantDevice}
     * @memberof CustomAssistantRequestBody
     */
    device: CustomAssistantDevice;
    /**
     * 
     * @type {CustomAssistantUser}
     * @memberof CustomAssistantRequestBody
     */
    user: CustomAssistantUser;
}

/**
 * 
 * @export
 * @interface CustomAssistantRequestContext
 */
export interface CustomAssistantRequestContext {
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantRequestContext
     */
    sessionId: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantRequestContext
     */
    noTracking?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantRequestContext
     */
    requestType: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantRequestContext
     */
    requestName?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CustomAssistantRequestContext
     */
    slots?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantRequestContext
     */
    originalInput?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantRequestContext
     */
    channel: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantRequestContext
     */
    requiresLanguageUnderstanding?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantRequestContext
     */
    locale?: string;
}

/**
 * 
 * @export
 * @interface CustomAssistantResponse
 */
export interface CustomAssistantResponse {
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantResponse
     */
    responseId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantResponse
     */
    ssml?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantResponse
     */
    outputSpeech?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantResponse
     */
    displayText?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantResponse
     */
    displayTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantResponse
     */
    responseTemplate?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof CustomAssistantResponse
     */
    foregroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof CustomAssistantResponse
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof CustomAssistantResponse
     */
    audioFile?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof CustomAssistantResponse
     */
    videoFile?: MediaItemModel;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CustomAssistantResponse
     */
    sessionAttributes?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomAssistantResponse
     */
    hints?: Array<string>;
    /**
     * 
     * @type {Array<CustomAssistantListItem>}
     * @memberof CustomAssistantResponse
     */
    listItems?: Array<CustomAssistantListItem>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAssistantResponse
     */
    endSession?: boolean;
}

/**
 * 
 * @export
 * @interface CustomAssistantUser
 */
export interface CustomAssistantUser {
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantUser
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAssistantUser
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    deviceId?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Device
     */
    supportedInterfaces?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface DialogflowResponse
 */
export interface DialogflowResponse {
    /**
     * 
     * @type {string}
     * @memberof DialogflowResponse
     */
    fulfillmentText?: string;
    /**
     * 
     * @type {Array<FulfillmentMessage>}
     * @memberof DialogflowResponse
     */
    fulfillmentMessages?: Array<FulfillmentMessage>;
    /**
     * 
     * @type {string}
     * @memberof DialogflowResponse
     */
    source?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DialogflowResponse
     */
    payload?: { [key: string]: any; };
    /**
     * 
     * @type {Array<ActionOutputContext>}
     * @memberof DialogflowResponse
     */
    outputContexts?: Array<ActionOutputContext>;
    /**
     * 
     * @type {FollowupEventInput}
     * @memberof DialogflowResponse
     */
    followupEventInput?: FollowupEventInput;
}

/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface FollowupEventInput
 */
export interface FollowupEventInput {
    /**
     * 
     * @type {string}
     * @memberof FollowupEventInput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FollowupEventInput
     */
    languageCode?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FollowupEventInput
     */
    parameters?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface FulfillmentBasicCard
 */
export interface FulfillmentBasicCard {
    /**
     * 
     * @type {string}
     * @memberof FulfillmentBasicCard
     */
    formattedText?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentBasicCard
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentBasicCard
     */
    subtitle?: string;
    /**
     * 
     * @type {FulfillmentImage}
     * @memberof FulfillmentBasicCard
     */
    image?: FulfillmentImage;
}

/**
 * 
 * @export
 * @interface FulfillmentCard
 */
export interface FulfillmentCard {
    /**
     * 
     * @type {string}
     * @memberof FulfillmentCard
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentCard
     */
    subtitle?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentCard
     */
    imageUri?: string;
    /**
     * 
     * @type {Array<CardButton>}
     * @memberof FulfillmentCard
     */
    buttons?: Array<CardButton>;
}

/**
 * 
 * @export
 * @interface FulfillmentCarouselSelect
 */
export interface FulfillmentCarouselSelect {
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof FulfillmentCarouselSelect
     */
    items?: Array<ListItem>;
}

/**
 * 
 * @export
 * @interface FulfillmentImage
 */
export interface FulfillmentImage {
    /**
     * 
     * @type {string}
     * @memberof FulfillmentImage
     */
    imageUri?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentImage
     */
    accessibilityText?: string;
}

/**
 * 
 * @export
 * @interface FulfillmentListSelect
 */
export interface FulfillmentListSelect {
    /**
     * 
     * @type {string}
     * @memberof FulfillmentListSelect
     */
    title?: string;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof FulfillmentListSelect
     */
    items?: Array<ListItem>;
}

/**
 * 
 * @export
 * @interface FulfillmentMessage
 */
export interface FulfillmentMessage {
    /**
     * 
     * @type {string}
     * @memberof FulfillmentMessage
     */
    platform?: string;
    /**
     * 
     * @type {FulfillmentText}
     * @memberof FulfillmentMessage
     */
    text?: FulfillmentText;
    /**
     * 
     * @type {FulfillmentImage}
     * @memberof FulfillmentMessage
     */
    image?: FulfillmentImage;
    /**
     * 
     * @type {FulfillmentCard}
     * @memberof FulfillmentMessage
     */
    card?: FulfillmentCard;
    /**
     * 
     * @type {FulfillmentBasicCard}
     * @memberof FulfillmentMessage
     */
    basicCard?: FulfillmentBasicCard;
    /**
     * 
     * @type {any}
     * @memberof FulfillmentMessage
     */
    payload?: any;
    /**
     * 
     * @type {FulfillmentSuggestions}
     * @memberof FulfillmentMessage
     */
    suggestions?: FulfillmentSuggestions;
    /**
     * 
     * @type {FulfillmentListSelect}
     * @memberof FulfillmentMessage
     */
    listSelect?: FulfillmentListSelect;
    /**
     * 
     * @type {FulfillmentCarouselSelect}
     * @memberof FulfillmentMessage
     */
    carouselSelect?: FulfillmentCarouselSelect;
    /**
     * 
     * @type {FulfillmentSimpleResponses}
     * @memberof FulfillmentMessage
     */
    simpleResponses?: FulfillmentSimpleResponses;
}

/**
 * 
 * @export
 * @interface FulfillmentSimpleResponses
 */
export interface FulfillmentSimpleResponses {
    /**
     * 
     * @type {Array<SimpleResponseItem>}
     * @memberof FulfillmentSimpleResponses
     */
    simpleResponses?: Array<SimpleResponseItem>;
}

/**
 * 
 * @export
 * @interface FulfillmentSuggestions
 */
export interface FulfillmentSuggestions {
    /**
     * 
     * @type {Array<Suggestion>}
     * @memberof FulfillmentSuggestions
     */
    suggestions?: Array<Suggestion>;
}

/**
 * 
 * @export
 * @interface FulfillmentText
 */
export interface FulfillmentText {
    /**
     * 
     * @type {Array<string>}
     * @memberof FulfillmentText
     */
    text?: Array<string>;
}

/**
 * 
 * @export
 * @interface Geolocation
 */
export interface Geolocation {
    /**
     * 
     * @type {LocationServices}
     * @memberof Geolocation
     */
    locationServices?: LocationServices;
    /**
     * 
     * @type {Date}
     * @memberof Geolocation
     */
    timestamp?: Date;
    /**
     * 
     * @type {GeolocationCoordinate}
     * @memberof Geolocation
     */
    coordinate?: GeolocationCoordinate;
    /**
     * 
     * @type {GeolocationAltitude}
     * @memberof Geolocation
     */
    altitude?: GeolocationAltitude;
    /**
     * 
     * @type {GeolocationHeading}
     * @memberof Geolocation
     */
    heading?: GeolocationHeading;
    /**
     * 
     * @type {GeolocationSpeed}
     * @memberof Geolocation
     */
    speed?: GeolocationSpeed;
}

/**
 * 
 * @export
 * @interface GeolocationAltitude
 */
export interface GeolocationAltitude {
    /**
     * 
     * @type {number}
     * @memberof GeolocationAltitude
     */
    altitudeInMeters?: number;
    /**
     * 
     * @type {number}
     * @memberof GeolocationAltitude
     */
    accuracyInMeters?: number;
}

/**
 * 
 * @export
 * @interface GeolocationCoordinate
 */
export interface GeolocationCoordinate {
    /**
     * 
     * @type {number}
     * @memberof GeolocationCoordinate
     */
    latitudeInDegrees?: number;
    /**
     * 
     * @type {number}
     * @memberof GeolocationCoordinate
     */
    longitudeInDegrees?: number;
    /**
     * 
     * @type {number}
     * @memberof GeolocationCoordinate
     */
    accuracyInMeters?: number;
}

/**
 * 
 * @export
 * @interface GeolocationHeading
 */
export interface GeolocationHeading {
    /**
     * 
     * @type {number}
     * @memberof GeolocationHeading
     */
    directionInDegrees?: number;
    /**
     * 
     * @type {number}
     * @memberof GeolocationHeading
     */
    accuracyInDegrees?: number;
}

/**
 * 
 * @export
 * @interface GeolocationSpeed
 */
export interface GeolocationSpeed {
    /**
     * 
     * @type {number}
     * @memberof GeolocationSpeed
     */
    speedInMetersPerSecond?: number;
    /**
     * 
     * @type {number}
     * @memberof GeolocationSpeed
     */
    accuracyInMetresPerSecond?: number;
}

/**
 * 
 * @export
 * @interface ICard
 */
export interface ICard {
    /**
     * 
     * @type {string}
     * @memberof ICard
     */
    type: string;
}

/**
 * 
 * @export
 * @interface IDirective
 */
export interface IDirective {
    /**
     * 
     * @type {string}
     * @memberof IDirective
     */
    type: string;
}

/**
 * 
 * @export
 * @interface IOutputSpeech
 */
export interface IOutputSpeech {
    /**
     * 
     * @type {string}
     * @memberof IOutputSpeech
     */
    type: string;
}

/**
 * 
 * @export
 * @interface ListItem
 */
export interface ListItem {
    /**
     * 
     * @type {ListItemInfo}
     * @memberof ListItem
     */
    info?: ListItemInfo;
    /**
     * 
     * @type {string}
     * @memberof ListItem
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ListItem
     */
    description?: string;
    /**
     * 
     * @type {FulfillmentImage}
     * @memberof ListItem
     */
    image?: FulfillmentImage;
}

/**
 * 
 * @export
 * @interface ListItemInfo
 */
export interface ListItemInfo {
    /**
     * 
     * @type {string}
     * @memberof ListItemInfo
     */
    key?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListItemInfo
     */
    synonyms?: Array<string>;
}

/**
 * 
 * @export
 * @interface LocationServices
 */
export interface LocationServices {
    /**
     * 
     * @type {string}
     * @memberof LocationServices
     */
    access?: LocationServices.AccessEnum;
    /**
     * 
     * @type {string}
     * @memberof LocationServices
     */
    status?: LocationServices.StatusEnum;
}

/**
 * @export
 * @namespace LocationServices
 */
export namespace LocationServices {
    /**
     * @export
     * @enum {string}
     */
    export enum AccessEnum {
        ENABLED = <any> 'ENABLED',
        DISABLED = <any> 'DISABLED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        RUNNING = <any> 'RUNNING',
        STOPPED = <any> 'STOPPED'
    }
}

/**
 * 
 * @export
 * @interface MediaItemModel
 */
export interface MediaItemModel {
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    fileExtension?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    mediaType?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    applicationId?: string;
    /**
     * 
     * @type {Date}
     * @memberof MediaItemModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    caption?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MediaItemModel
     */
    isDisabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    modifiedByUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {UserModel}
     * @memberof MediaItemModel
     */
    modifiedByUser?: UserModel;
}

/**
 * 
 * @export
 * @interface MessageReaction
 */
export interface MessageReaction {
    /**
     * 
     * @type {string}
     * @memberof MessageReaction
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface OriginalDetectIntentRequest
 */
export interface OriginalDetectIntentRequest {
    /**
     * 
     * @type {string}
     * @memberof OriginalDetectIntentRequest
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalDetectIntentRequest
     */
    version?: string;
    /**
     * 
     * @type {any}
     * @memberof OriginalDetectIntentRequest
     */
    payload?: any;
}

/**
 * 
 * @export
 * @interface Permissions
 */
export interface Permissions {
    /**
     * 
     * @type {string}
     * @memberof Permissions
     */
    consentToken?: string;
    /**
     * 
     * @type {{ [key: string]: Scope; }}
     * @memberof Permissions
     */
    scopes?: { [key: string]: Scope; };
}

/**
 * 
 * @export
 * @interface PlaybackState
 */
export interface PlaybackState {
    /**
     * 
     * @type {string}
     * @memberof PlaybackState
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof PlaybackState
     */
    offsetInMilliseconds?: number;
    /**
     * 
     * @type {string}
     * @memberof PlaybackState
     */
    playerActivity?: string;
}

/**
 * 
 * @export
 * @interface Reprompt
 */
export interface Reprompt {
    /**
     * 
     * @type {IOutputSpeech}
     * @memberof Reprompt
     */
    outputSpeech?: IOutputSpeech;
}

/**
 * 
 * @export
 * @interface Request
 */
export interface Request {
    /**
     * 
     * @type {string}
     * @memberof Request
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Request
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof Request
     */
    locale?: string;
    /**
     * 
     * @type {Date}
     * @memberof Request
     */
    timestamp?: Date;
}

/**
 * 
 * @export
 * @interface ResponseBody
 */
export interface ResponseBody {
    /**
     * 
     * @type {IOutputSpeech}
     * @memberof ResponseBody
     */
    outputSpeech?: IOutputSpeech;
    /**
     * 
     * @type {ICard}
     * @memberof ResponseBody
     */
    card?: ICard;
    /**
     * 
     * @type {Reprompt}
     * @memberof ResponseBody
     */
    reprompt?: Reprompt;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseBody
     */
    shouldEndSession?: boolean;
    /**
     * 
     * @type {Array<IDirective>}
     * @memberof ResponseBody
     */
    directives?: Array<IDirective>;
}

/**
 * 
 * @export
 * @interface Scope
 */
export interface Scope {
    /**
     * 
     * @type {string}
     * @memberof Scope
     */
    status?: string;
}

/**
 * 
 * @export
 * @interface SemanticAction
 */
export interface SemanticAction {
    /**
     * 
     * @type {string}
     * @memberof SemanticAction
     */
    id?: string;
    /**
     * 
     * @type {{ [key: string]: Entity; }}
     * @memberof SemanticAction
     */
    entities?: { [key: string]: Entity; };
}

/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    _new?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    sessionId?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Session
     */
    attributes?: { [key: string]: any; };
    /**
     * 
     * @type {Application}
     * @memberof Session
     */
    application?: Application;
    /**
     * 
     * @type {User}
     * @memberof Session
     */
    user?: User;
}

/**
 * 
 * @export
 * @interface SimpleResponseItem
 */
export interface SimpleResponseItem {
    /**
     * 
     * @type {string}
     * @memberof SimpleResponseItem
     */
    textToSpeech?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleResponseItem
     */
    ssml?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleResponseItem
     */
    displayText?: string;
}

/**
 * 
 * @export
 * @interface SkillResponse
 */
export interface SkillResponse {
    /**
     * 
     * @type {string}
     * @memberof SkillResponse
     */
    version: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SkillResponse
     */
    sessionAttributes?: { [key: string]: any; };
    /**
     * 
     * @type {ResponseBody}
     * @memberof SkillResponse
     */
    response: ResponseBody;
}

/**
 * 
 * @export
 * @interface SuggestedActions
 */
export interface SuggestedActions {
    /**
     * 
     * @type {Array<string>}
     * @memberof SuggestedActions
     */
    to?: Array<string>;
    /**
     * 
     * @type {Array<CardAction>}
     * @memberof SuggestedActions
     */
    actions?: Array<CardAction>;
}

/**
 * 
 * @export
 * @interface Suggestion
 */
export interface Suggestion {
    /**
     * 
     * @type {string}
     * @memberof Suggestion
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TextHighlight
 */
export interface TextHighlight {
    /**
     * 
     * @type {string}
     * @memberof TextHighlight
     */
    text?: string;
    /**
     * 
     * @type {number}
     * @memberof TextHighlight
     */
    occurrence?: number;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    accessToken?: string;
    /**
     * 
     * @type {Permissions}
     * @memberof User
     */
    permissions?: Permissions;
}

/**
 * 
 * @export
 * @interface UserModel
 */
export interface UserModel {
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    lastName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserModel
     */
    isAdmin?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    imageUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserModel
     */
    isApiUser?: boolean;
}

/**
 * 
 * @export
 * @interface VideoSupport
 */
export interface VideoSupport {
    /**
     * 
     * @type {Array<string>}
     * @memberof VideoSupport
     */
    codecs?: Array<string>;
}

/**
 * 
 * @export
 * @interface ViewportExperience
 */
export interface ViewportExperience {
    /**
     * 
     * @type {boolean}
     * @memberof ViewportExperience
     */
    canResize?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ViewportExperience
     */
    canRotate?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ViewportExperience
     */
    arcMinuteWidth?: number;
    /**
     * 
     * @type {number}
     * @memberof ViewportExperience
     */
    arcMinuteHeight?: number;
}

/**
 * 
 * @export
 * @interface VivContext
 */
export interface VivContext {
    /**
     * 
     * @type {string}
     * @memberof VivContext
     */
    clientAppVersion?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VivContext
     */
    is24HourFormat?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VivContext
     */
    timezone?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VivContext
     */
    handsFree?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VivContext
     */
    screenLocked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VivContext
     */
    sessionId?: string;
    /**
     * 
     * @type {string}
     * @memberof VivContext
     */
    locale?: string;
    /**
     * 
     * @type {any}
     * @memberof VivContext
     */
    grantedPermissions?: any;
    /**
     * 
     * @type {string}
     * @memberof VivContext
     */
    clientAppId?: string;
    /**
     * 
     * @type {string}
     * @memberof VivContext
     */
    device?: string;
    /**
     * 
     * @type {string}
     * @memberof VivContext
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof VivContext
     */
    canTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof VivContext
     */
    bixbyUserId?: string;
}


/**
 * AlexaApi - fetch parameter creator
 * @export
 */
export const AlexaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handles an unsigned request from Alexa. This endpoint can be used from existing skills without validating Alexa certificates.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {APLSkillRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleLocalRequest(applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Alexa/HandleRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"APLSkillRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handles a signed request from Alexa. This endpoint validates the certificates coming from amazon and the skill id sent.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {APLSkillRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleSignedRequest(applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Alexa/HandleSignedRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"APLSkillRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlexaApi - functional programming interface
 * @export
 */
export const AlexaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handles an unsigned request from Alexa. This endpoint can be used from existing skills without validating Alexa certificates.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {APLSkillRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleLocalRequest(applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SkillResponse> {
            const localVarFetchArgs = AlexaApiFetchParamCreator(configuration).handleLocalRequest(applicationId, applicationSecret, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Handles a signed request from Alexa. This endpoint validates the certificates coming from amazon and the skill id sent.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {APLSkillRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleSignedRequest(applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SkillResponse> {
            const localVarFetchArgs = AlexaApiFetchParamCreator(configuration).handleSignedRequest(applicationId, applicationSecret, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AlexaApi - factory interface
 * @export
 */
export const AlexaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Handles an unsigned request from Alexa. This endpoint can be used from existing skills without validating Alexa certificates.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {APLSkillRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleLocalRequest(applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options?: any) {
            return AlexaApiFp(configuration).handleLocalRequest(applicationId, applicationSecret, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Handles a signed request from Alexa. This endpoint validates the certificates coming from amazon and the skill id sent.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {APLSkillRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleSignedRequest(applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options?: any) {
            return AlexaApiFp(configuration).handleSignedRequest(applicationId, applicationSecret, request, options)(fetch, basePath);
        },
    };
};

/**
 * AlexaApi - interface
 * @export
 * @interface AlexaApi
 */
export interface AlexaApiInterface {
    /**
     * 
     * @summary Handles an unsigned request from Alexa. This endpoint can be used from existing skills without validating Alexa certificates.
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {APLSkillRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlexaApiInterface
     */
    handleLocalRequest(applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options?: any): Promise<SkillResponse>;

    /**
     * 
     * @summary Handles a signed request from Alexa. This endpoint validates the certificates coming from amazon and the skill id sent.
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {APLSkillRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlexaApiInterface
     */
    handleSignedRequest(applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options?: any): Promise<SkillResponse>;

}

/**
 * AlexaApi - object-oriented interface
 * @export
 * @class AlexaApi
 * @extends {BaseAPI}
 */
export class AlexaApi extends BaseAPI implements AlexaApiInterface {
    /**
     * 
     * @summary Handles an unsigned request from Alexa. This endpoint can be used from existing skills without validating Alexa certificates.
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {APLSkillRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlexaApi
     */
    public handleLocalRequest(applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options?: any) {
        return AlexaApiFp(this.configuration).handleLocalRequest(applicationId, applicationSecret, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Handles a signed request from Alexa. This endpoint validates the certificates coming from amazon and the skill id sent.
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {APLSkillRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlexaApi
     */
    public handleSignedRequest(applicationId?: string, applicationSecret?: string, request?: APLSkillRequest, options?: any) {
        return AlexaApiFp(this.configuration).handleSignedRequest(applicationId, applicationSecret, request, options)(this.fetch, this.basePath);
    }

}

/**
 * BixbyApi - fetch parameter creator
 * @export
 */
export const BixbyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} actionName 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCustomRequest(actionName: string, applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'actionName' is not null or undefined
            if (actionName === null || actionName === undefined) {
                throw new RequiredError('actionName','Required parameter actionName was null or undefined when calling handleCustomRequest.');
            }
            const localVarPath = `/api/Bixby/HandleRequest/Custom/{actionName}`
                .replace(`{${"actionName"}}`, encodeURIComponent(String(actionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyGeneralQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDynamicRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/Dynamic`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyGeneralQuestionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventGeneralSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/EventGeneralSearch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyEventSearchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventLocationSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/EventLocationSearch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyEventSearchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventStartTimeSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/EventStartTimeSearch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyEventSearchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventStatusSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/EventStatusSearch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyEventSearchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyGeneralQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleGeneralQuestionRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/GeneralQuestion`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyGeneralQuestionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyGoToStepRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleGoToStepRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGoToStepRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/GoToStep`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyGoToStepRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHelpRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/Help`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleLatestMessageRequest(applicationId?: string, applicationSecret?: string, model?: BixbyLatestMessageRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/LatestMessage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyLatestMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyItemSelectedRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleListItemSelectRequest(applicationId?: string, applicationSecret?: string, model?: BixbyItemSelectedRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/ListItemSelect`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyItemSelectedRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMoreRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/More`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNextRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/Next`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNoRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/No`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyNumberRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNumberRequest(applicationId?: string, applicationSecret?: string, model?: BixbyNumberRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/Number`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyNumberRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handlePrevisousRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/Previous`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRecipeDetailsRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/RecipeDetails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyRecipeSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRecipeSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyRecipeSearchRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/RecipeSearch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyRecipeSearchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleStartOverRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/StartOver`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleStartRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/Start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleStopRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/Stop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleWelcomeRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/Welcome`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleYesRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Bixby/HandleRequest/Yes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BixbyActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BixbyApi - functional programming interface
 * @export
 */
export const BixbyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} actionName 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCustomRequest(actionName: string, applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleCustomRequest(actionName, applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyGeneralQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDynamicRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleDynamicRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventGeneralSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleEventGeneralSearchRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventLocationSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleEventLocationSearchRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventStartTimeSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleEventStartTimeSearchRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventStatusSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleEventStatusSearchRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyGeneralQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleGeneralQuestionRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleGeneralQuestionRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyGoToStepRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleGoToStepRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGoToStepRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleGoToStepRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHelpRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleHelpRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleLatestMessageRequest(applicationId?: string, applicationSecret?: string, model?: BixbyLatestMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleLatestMessageRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyItemSelectedRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleListItemSelectRequest(applicationId?: string, applicationSecret?: string, model?: BixbyItemSelectedRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleListItemSelectRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMoreRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleMoreRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNextRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleNextRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNoRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleNoRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyNumberRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNumberRequest(applicationId?: string, applicationSecret?: string, model?: BixbyNumberRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleNumberRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handlePrevisousRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handlePrevisousRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRecipeDetailsRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleRecipeDetailsRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyRecipeSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRecipeSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyRecipeSearchRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleRecipeSearchRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleStartOverRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleStartOverRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleStartRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleStartRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleStopRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleStopRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleWelcomeRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleWelcomeRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleYesRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BixbyResponse> {
            const localVarFetchArgs = BixbyApiFetchParamCreator(configuration).handleYesRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BixbyApi - factory interface
 * @export
 */
export const BixbyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} actionName 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCustomRequest(actionName: string, applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleCustomRequest(actionName, applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyGeneralQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDynamicRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options?: any) {
            return BixbyApiFp(configuration).handleDynamicRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventGeneralSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any) {
            return BixbyApiFp(configuration).handleEventGeneralSearchRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventLocationSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any) {
            return BixbyApiFp(configuration).handleEventLocationSearchRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventStartTimeSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any) {
            return BixbyApiFp(configuration).handleEventStartTimeSearchRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyEventSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEventStatusSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any) {
            return BixbyApiFp(configuration).handleEventStatusSearchRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyGeneralQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleGeneralQuestionRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options?: any) {
            return BixbyApiFp(configuration).handleGeneralQuestionRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyGoToStepRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleGoToStepRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGoToStepRequest, options?: any) {
            return BixbyApiFp(configuration).handleGoToStepRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHelpRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleHelpRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleLatestMessageRequest(applicationId?: string, applicationSecret?: string, model?: BixbyLatestMessageRequest, options?: any) {
            return BixbyApiFp(configuration).handleLatestMessageRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyItemSelectedRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleListItemSelectRequest(applicationId?: string, applicationSecret?: string, model?: BixbyItemSelectedRequest, options?: any) {
            return BixbyApiFp(configuration).handleListItemSelectRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMoreRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleMoreRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNextRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleNextRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNoRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleNoRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyNumberRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNumberRequest(applicationId?: string, applicationSecret?: string, model?: BixbyNumberRequest, options?: any) {
            return BixbyApiFp(configuration).handleNumberRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handlePrevisousRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handlePrevisousRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRecipeDetailsRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleRecipeDetailsRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyRecipeSearchRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRecipeSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyRecipeSearchRequest, options?: any) {
            return BixbyApiFp(configuration).handleRecipeSearchRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleStartOverRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleStartOverRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleStartRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleStartRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleStopRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleStopRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleWelcomeRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleWelcomeRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {BixbyActionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleYesRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
            return BixbyApiFp(configuration).handleYesRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
    };
};

/**
 * BixbyApi - interface
 * @export
 * @interface BixbyApi
 */
export interface BixbyApiInterface {
    /**
     * 
     * @param {string} actionName 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleCustomRequest(actionName: string, applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyGeneralQuestionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleDynamicRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyEventSearchRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleEventGeneralSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyEventSearchRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleEventLocationSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyEventSearchRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleEventStartTimeSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyEventSearchRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleEventStatusSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyGeneralQuestionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleGeneralQuestionRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyGoToStepRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleGoToStepRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGoToStepRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleHelpRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyLatestMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleLatestMessageRequest(applicationId?: string, applicationSecret?: string, model?: BixbyLatestMessageRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyItemSelectedRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleListItemSelectRequest(applicationId?: string, applicationSecret?: string, model?: BixbyItemSelectedRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleMoreRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleNextRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleNoRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyNumberRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleNumberRequest(applicationId?: string, applicationSecret?: string, model?: BixbyNumberRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handlePrevisousRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleRecipeDetailsRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyRecipeSearchRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleRecipeSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyRecipeSearchRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleStartOverRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleStartRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleStopRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleWelcomeRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApiInterface
     */
    handleYesRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any): Promise<BixbyResponse>;

}

/**
 * BixbyApi - object-oriented interface
 * @export
 * @class BixbyApi
 * @extends {BaseAPI}
 */
export class BixbyApi extends BaseAPI implements BixbyApiInterface {
    /**
     * 
     * @param {string} actionName 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleCustomRequest(actionName: string, applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleCustomRequest(actionName, applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyGeneralQuestionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleDynamicRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleDynamicRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyEventSearchRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleEventGeneralSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleEventGeneralSearchRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyEventSearchRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleEventLocationSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleEventLocationSearchRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyEventSearchRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleEventStartTimeSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleEventStartTimeSearchRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyEventSearchRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleEventStatusSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyEventSearchRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleEventStatusSearchRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyGeneralQuestionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleGeneralQuestionRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGeneralQuestionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleGeneralQuestionRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyGoToStepRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleGoToStepRequest(applicationId?: string, applicationSecret?: string, model?: BixbyGoToStepRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleGoToStepRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleHelpRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleHelpRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyLatestMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleLatestMessageRequest(applicationId?: string, applicationSecret?: string, model?: BixbyLatestMessageRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleLatestMessageRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyItemSelectedRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleListItemSelectRequest(applicationId?: string, applicationSecret?: string, model?: BixbyItemSelectedRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleListItemSelectRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleMoreRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleMoreRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleNextRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleNextRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleNoRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleNoRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyNumberRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleNumberRequest(applicationId?: string, applicationSecret?: string, model?: BixbyNumberRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleNumberRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handlePrevisousRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handlePrevisousRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleRecipeDetailsRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleRecipeDetailsRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyRecipeSearchRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleRecipeSearchRequest(applicationId?: string, applicationSecret?: string, model?: BixbyRecipeSearchRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleRecipeSearchRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleStartOverRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleStartOverRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleStartRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleStartRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleStopRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleStopRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleWelcomeRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleWelcomeRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {BixbyActionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyApi
     */
    public handleYesRequest(applicationId?: string, applicationSecret?: string, model?: BixbyActionRequest, options?: any) {
        return BixbyApiFp(this.configuration).handleYesRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

}

/**
 * BotServiceApi - fetch parameter creator
 * @export
 */
export const BotServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Used for getting the direct activity response rather than having it posted to a full bot service.  This endpoint is useful for testing scenarios as well as adding voicify on top of existing bot framework  servers
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {Activity} [activity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleActivityRequest(applicationId?: string, applicationSecret?: string, activity?: Activity, options: any = {}): FetchArgs {
            const localVarPath = `/api/BotService/HandleActivityRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Activity" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(activity || {}) : (activity || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used for handling full Azure Bot Service requests. This endpoint validates against your MS app ID and Secret and will POST back to the activity's channel with no return type.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {string} [nluTool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, nluTool?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/BotService/HandleRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            if (nluTool !== undefined) {
                localVarQueryParameter['nluTool'] = nluTool;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotServiceApi - functional programming interface
 * @export
 */
export const BotServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Used for getting the direct activity response rather than having it posted to a full bot service.  This endpoint is useful for testing scenarios as well as adding voicify on top of existing bot framework  servers
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {Activity} [activity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleActivityRequest(applicationId?: string, applicationSecret?: string, activity?: Activity, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BotServiceApiFetchParamCreator(configuration).handleActivityRequest(applicationId, applicationSecret, activity, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Used for handling full Azure Bot Service requests. This endpoint validates against your MS app ID and Secret and will POST back to the activity's channel with no return type.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {string} [nluTool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, nluTool?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BotServiceApiFetchParamCreator(configuration).handleRequest(applicationId, applicationSecret, nluTool, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BotServiceApi - factory interface
 * @export
 */
export const BotServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Used for getting the direct activity response rather than having it posted to a full bot service.  This endpoint is useful for testing scenarios as well as adding voicify on top of existing bot framework  servers
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {Activity} [activity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleActivityRequest(applicationId?: string, applicationSecret?: string, activity?: Activity, options?: any) {
            return BotServiceApiFp(configuration).handleActivityRequest(applicationId, applicationSecret, activity, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Used for handling full Azure Bot Service requests. This endpoint validates against your MS app ID and Secret and will POST back to the activity's channel with no return type.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {string} [nluTool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, nluTool?: string, options?: any) {
            return BotServiceApiFp(configuration).handleRequest(applicationId, applicationSecret, nluTool, options)(fetch, basePath);
        },
    };
};

/**
 * BotServiceApi - interface
 * @export
 * @interface BotServiceApi
 */
export interface BotServiceApiInterface {
    /**
     * 
     * @summary Used for getting the direct activity response rather than having it posted to a full bot service.  This endpoint is useful for testing scenarios as well as adding voicify on top of existing bot framework  servers
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {Activity} [activity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotServiceApiInterface
     */
    handleActivityRequest(applicationId?: string, applicationSecret?: string, activity?: Activity, options?: any): Promise<{}>;

    /**
     * 
     * @summary Used for handling full Azure Bot Service requests. This endpoint validates against your MS app ID and Secret and will POST back to the activity's channel with no return type.
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {string} [nluTool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotServiceApiInterface
     */
    handleRequest(applicationId?: string, applicationSecret?: string, nluTool?: string, options?: any): Promise<{}>;

}

/**
 * BotServiceApi - object-oriented interface
 * @export
 * @class BotServiceApi
 * @extends {BaseAPI}
 */
export class BotServiceApi extends BaseAPI implements BotServiceApiInterface {
    /**
     * 
     * @summary Used for getting the direct activity response rather than having it posted to a full bot service.  This endpoint is useful for testing scenarios as well as adding voicify on top of existing bot framework  servers
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {Activity} [activity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotServiceApi
     */
    public handleActivityRequest(applicationId?: string, applicationSecret?: string, activity?: Activity, options?: any) {
        return BotServiceApiFp(this.configuration).handleActivityRequest(applicationId, applicationSecret, activity, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Used for handling full Azure Bot Service requests. This endpoint validates against your MS app ID and Secret and will POST back to the activity's channel with no return type.
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {string} [nluTool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotServiceApi
     */
    public handleRequest(applicationId?: string, applicationSecret?: string, nluTool?: string, options?: any) {
        return BotServiceApiFp(this.configuration).handleRequest(applicationId, applicationSecret, nluTool, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomAssistantApi - fetch parameter creator
 * @export
 */
export const CustomAssistantApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handles requests from a custom assistant. You can optionally pass in pre-processed and aligned NLU data or let Voicify handle it behind the scenes.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {CustomAssistantRequestBody} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, model?: CustomAssistantRequestBody, options: any = {}): FetchArgs {
            const localVarPath = `/api/CustomAssistant/HandleRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomAssistantRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomAssistantApi - functional programming interface
 * @export
 */
export const CustomAssistantApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handles requests from a custom assistant. You can optionally pass in pre-processed and aligned NLU data or let Voicify handle it behind the scenes.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {CustomAssistantRequestBody} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, model?: CustomAssistantRequestBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomAssistantResponse> {
            const localVarFetchArgs = CustomAssistantApiFetchParamCreator(configuration).handleRequest(applicationId, applicationSecret, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomAssistantApi - factory interface
 * @export
 */
export const CustomAssistantApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Handles requests from a custom assistant. You can optionally pass in pre-processed and aligned NLU data or let Voicify handle it behind the scenes.
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {CustomAssistantRequestBody} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, model?: CustomAssistantRequestBody, options?: any) {
            return CustomAssistantApiFp(configuration).handleRequest(applicationId, applicationSecret, model, options)(fetch, basePath);
        },
    };
};

/**
 * CustomAssistantApi - interface
 * @export
 * @interface CustomAssistantApi
 */
export interface CustomAssistantApiInterface {
    /**
     * 
     * @summary Handles requests from a custom assistant. You can optionally pass in pre-processed and aligned NLU data or let Voicify handle it behind the scenes.
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {CustomAssistantRequestBody} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomAssistantApiInterface
     */
    handleRequest(applicationId?: string, applicationSecret?: string, model?: CustomAssistantRequestBody, options?: any): Promise<CustomAssistantResponse>;

}

/**
 * CustomAssistantApi - object-oriented interface
 * @export
 * @class CustomAssistantApi
 * @extends {BaseAPI}
 */
export class CustomAssistantApi extends BaseAPI implements CustomAssistantApiInterface {
    /**
     * 
     * @summary Handles requests from a custom assistant. You can optionally pass in pre-processed and aligned NLU data or let Voicify handle it behind the scenes.
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {CustomAssistantRequestBody} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomAssistantApi
     */
    public handleRequest(applicationId?: string, applicationSecret?: string, model?: CustomAssistantRequestBody, options?: any) {
        return CustomAssistantApiFp(this.configuration).handleRequest(applicationId, applicationSecret, model, options)(this.fetch, this.basePath);
    }

}

/**
 * DialogflowApi - fetch parameter creator
 * @export
 */
export const DialogflowApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handles a webhook fulfillment request from dialogflow and returns a dialogflow structured response
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {ActionRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, request?: ActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Dialogflow/HandleRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DialogflowApi - functional programming interface
 * @export
 */
export const DialogflowApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handles a webhook fulfillment request from dialogflow and returns a dialogflow structured response
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {ActionRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, request?: ActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DialogflowResponse> {
            const localVarFetchArgs = DialogflowApiFetchParamCreator(configuration).handleRequest(applicationId, applicationSecret, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DialogflowApi - factory interface
 * @export
 */
export const DialogflowApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Handles a webhook fulfillment request from dialogflow and returns a dialogflow structured response
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {ActionRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, request?: ActionRequest, options?: any) {
            return DialogflowApiFp(configuration).handleRequest(applicationId, applicationSecret, request, options)(fetch, basePath);
        },
    };
};

/**
 * DialogflowApi - interface
 * @export
 * @interface DialogflowApi
 */
export interface DialogflowApiInterface {
    /**
     * 
     * @summary Handles a webhook fulfillment request from dialogflow and returns a dialogflow structured response
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {ActionRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DialogflowApiInterface
     */
    handleRequest(applicationId?: string, applicationSecret?: string, request?: ActionRequest, options?: any): Promise<DialogflowResponse>;

}

/**
 * DialogflowApi - object-oriented interface
 * @export
 * @class DialogflowApi
 * @extends {BaseAPI}
 */
export class DialogflowApi extends BaseAPI implements DialogflowApiInterface {
    /**
     * 
     * @summary Handles a webhook fulfillment request from dialogflow and returns a dialogflow structured response
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {ActionRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DialogflowApi
     */
    public handleRequest(applicationId?: string, applicationSecret?: string, request?: ActionRequest, options?: any) {
        return DialogflowApiFp(this.configuration).handleRequest(applicationId, applicationSecret, request, options)(this.fetch, this.basePath);
    }

}

/**
 * GoogleAssistantApi - fetch parameter creator
 * @export
 */
export const GoogleAssistantApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deprecated - use Dialogflow endpoints
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {ActionRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, request?: ActionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/GoogleAssistant/HandleRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ActionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleAssistantApi - functional programming interface
 * @export
 */
export const GoogleAssistantApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deprecated - use Dialogflow endpoints
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {ActionRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, request?: ActionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GoogleAssistantApiFetchParamCreator(configuration).handleRequest(applicationId, applicationSecret, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GoogleAssistantApi - factory interface
 * @export
 */
export const GoogleAssistantApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deprecated - use Dialogflow endpoints
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {ActionRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRequest(applicationId?: string, applicationSecret?: string, request?: ActionRequest, options?: any) {
            return GoogleAssistantApiFp(configuration).handleRequest(applicationId, applicationSecret, request, options)(fetch, basePath);
        },
    };
};

/**
 * GoogleAssistantApi - interface
 * @export
 * @interface GoogleAssistantApi
 */
export interface GoogleAssistantApiInterface {
    /**
     * 
     * @summary Deprecated - use Dialogflow endpoints
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {ActionRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAssistantApiInterface
     */
    handleRequest(applicationId?: string, applicationSecret?: string, request?: ActionRequest, options?: any): Promise<{}>;

}

/**
 * GoogleAssistantApi - object-oriented interface
 * @export
 * @class GoogleAssistantApi
 * @extends {BaseAPI}
 */
export class GoogleAssistantApi extends BaseAPI implements GoogleAssistantApiInterface {
    /**
     * 
     * @summary Deprecated - use Dialogflow endpoints
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {ActionRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAssistantApi
     */
    public handleRequest(applicationId?: string, applicationSecret?: string, request?: ActionRequest, options?: any) {
        return GoogleAssistantApiFp(this.configuration).handleRequest(applicationId, applicationSecret, request, options)(this.fetch, this.basePath);
    }

}

/**
 * HealthCheckApi - fetch parameter creator
 * @export
 */
export const HealthCheckApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options: any = {}): FetchArgs {
            const localVarPath = `/api/HealthCheck`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HealthCheckApiFetchParamCreator(configuration).healthCheck(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any) {
            return HealthCheckApiFp(configuration).healthCheck(options)(fetch, basePath);
        },
    };
};

/**
 * HealthCheckApi - interface
 * @export
 * @interface HealthCheckApi
 */
export interface HealthCheckApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApiInterface
     */
    healthCheck(options?: any): Promise<{}>;

}

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI implements HealthCheckApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApi
     */
    public healthCheck(options?: any) {
        return HealthCheckApiFp(this.configuration).healthCheck(options)(this.fetch, this.basePath);
    }

}

/**
 * UserProfileApi - fetch parameter creator
 * @export
 */
export const UserProfileApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the current session state data
         * @param {string} sessionId 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAttributes(sessionId: string, applicationId?: string, applicationSecret?: string, options: any = {}): FetchArgs {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling getSessionAttributes.');
            }
            const localVarPath = `/api/UserProfile/session/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (applicationSecret !== undefined) {
                localVarQueryParameter['applicationSecret'] = applicationSecret;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserProfileApi - functional programming interface
 * @export
 */
export const UserProfileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the current session state data
         * @param {string} sessionId 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAttributes(sessionId: string, applicationId?: string, applicationSecret?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConversationSessionState> {
            const localVarFetchArgs = UserProfileApiFetchParamCreator(configuration).getSessionAttributes(sessionId, applicationId, applicationSecret, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserProfileApi - factory interface
 * @export
 */
export const UserProfileApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Gets the current session state data
         * @param {string} sessionId 
         * @param {string} [applicationId] 
         * @param {string} [applicationSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAttributes(sessionId: string, applicationId?: string, applicationSecret?: string, options?: any) {
            return UserProfileApiFp(configuration).getSessionAttributes(sessionId, applicationId, applicationSecret, options)(fetch, basePath);
        },
    };
};

/**
 * UserProfileApi - interface
 * @export
 * @interface UserProfileApi
 */
export interface UserProfileApiInterface {
    /**
     * 
     * @summary Gets the current session state data
     * @param {string} sessionId 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApiInterface
     */
    getSessionAttributes(sessionId: string, applicationId?: string, applicationSecret?: string, options?: any): Promise<ConversationSessionState>;

}

/**
 * UserProfileApi - object-oriented interface
 * @export
 * @class UserProfileApi
 * @extends {BaseAPI}
 */
export class UserProfileApi extends BaseAPI implements UserProfileApiInterface {
    /**
     * 
     * @summary Gets the current session state data
     * @param {string} sessionId 
     * @param {string} [applicationId] 
     * @param {string} [applicationSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public getSessionAttributes(sessionId: string, applicationId?: string, applicationSecret?: string, options?: any) {
        return UserProfileApiFp(this.configuration).getSessionAttributes(sessionId, applicationId, applicationSecret, options)(this.fetch, this.basePath);
    }

}

